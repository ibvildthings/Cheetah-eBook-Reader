<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>eBook Reader Gesture Prototype</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #f5f5f5;
            overflow: hidden;
            touch-action: none;
            margin: 0;
            padding: 0;
        }
        
        #toolbar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            min-height: 60px;
            background: #fff;
            border-bottom: 1px solid #e5e7eb;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
            padding: 10px 20px;
            z-index: 300;
            box-shadow: 0 2px 8px rgba(0,0,0,.05);
            flex-wrap: wrap;
        }
        
        .toolbar-section {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: wrap;
        }
        
        .toolbar-label {
            font-size: 11px;
            font-weight: 600;
            color: #666;
            text-transform: uppercase;
            letter-spacing: .5px;
            white-space: nowrap;
        }
        
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding-top: 80px;
        }
        
        #reader-area {
            position: relative;
            background: #fff;
            box-shadow: 0 4px 20px rgba(0,0,0,.1);
            overflow-y: auto;
            transition: all .1s ease-out;
            max-height: calc(90vh - 80px);
        }
        
        .margin-handle {
            position: fixed;
            top: 50%;
            transform: translateY(-50%);
            width: 50px;
            height: 80px;
            cursor: ew-resize;
            z-index: 100;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .margin-handle-left {
            left: 0;
        }
        
        .margin-handle-right {
            right: 0;
        }
        
        .margin-indicator {
            width: 8px;
            height: 60px;
            background: #3b82f6;
            border-radius: 4px;
            opacity: .3;
            transition: all .2s;
            box-shadow: 0 2px 12px rgba(59,130,246,.4);
        }
        
        .margin-handle:hover .margin-indicator {
            opacity: .7;
            transform: scale(1.1);
        }
        
        .margin-handle.active .margin-indicator {
            opacity: 1;
            transform: scale(1.15);
            background: #2563eb;
        }
        
        #text-content {
            transition: padding .1s ease-out, opacity .2s ease-in-out;
            position: relative;
        }
        
        #text-content.transitioning {
            opacity: 0.4;
        }
        
        .mode-btn {
            padding: 6px 14px;
            border: 2px solid #e5e7eb;
            background: #fff;
            border-radius: 6px;
            font-size: 13px;
            cursor: pointer;
            transition: all .2s;
            font-weight: 500;
        }
        
        .mode-btn:hover {
            border-color: #3b82f6;
            background: #f0f9ff;
        }
        
        .mode-btn.active {
            border-color: #3b82f6;
            background: #3b82f6;
            color: #fff;
        }
        
        .speed-control {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .speed-control input[type=range] {
            flex: 1;
            min-width: 80px;
            width: 100px;
            height: 6px;
            border-radius: 3px;
            background: #e5e7eb;
            outline: 0;
            -webkit-appearance: none;
        }
        
        .speed-control input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #3b82f6;
            cursor: pointer;
        }
        
        .speed-control input[type=range]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #3b82f6;
            cursor: pointer;
            border: none;
        }
        
        .speed-label {
            font-size: 10px;
            color: #666;
            min-width: 45px;
            white-space: nowrap;
        }
        
        .play-btn {
            padding: 6px 16px;
            background: #3b82f6;
            color: #fff;
            border: none;
            border-radius: 6px;
            font-size: 13px;
            font-weight: 600;
            cursor: pointer;
            transition: background .2s;
        }
        
        .play-btn:hover {
            background: #2563eb;
        }
        
        .play-btn:disabled {
            background: #9ca3af;
            cursor: not-allowed;
        }
        
        .bionic {
            font-weight: 700;
        }
        
        .flow-word {
            transition: opacity .15s ease-out;
            font-weight: 400;
            cursor: pointer;
            display: inline;
            position: relative;
        }
        
        .flow-word:hover {
            opacity: .7;
        }
        
        .flow-word.active {
            opacity: 1;
            color: #1a1a1a;
        }
        
        .flow-word.inactive {
            opacity: .2;
        }
        
        .flow-word.inactive-always {
            opacity: .2;
            cursor: default;
        }
        
        /* Focus indicator overlay */
        #focus-indicator {
            position: absolute;
            top: 0;
            left: 0;
            pointer-events: none;
            z-index: 50;
            background: rgba(59, 130, 246, 0.08);
            transition: all 0.1s ease-out;
            display: none;
            border-radius: 3px;
        }
        
        #focus-indicator.visible {
            display: block;
        }
    </style>
</head>
<body>
    <div id="toolbar">
        <div class="toolbar-section">
            <span class="toolbar-label">Bionic</span>
            <button class="mode-btn" id="bionic-toggle">Off</button>
        </div>
        <div class="toolbar-section">
            <button class="mode-btn" id="flow-toggle">Flow Mode</button>
        </div>
        <div class="toolbar-section" id="flow-controls" style="display:none">
            <span class="toolbar-label">Speed</span>
            <div class="speed-control">
                <input type="range" id="speed-slider" min="100" max="600" value="300" step="10">
                <span class="speed-label" id="speed-label">300 wpm</span>
            </div>
            <span class="toolbar-label">Focus Width</span>
            <div class="speed-control">
                <input type="range" id="width-slider" min="1" max="4" value="2" step="0.5">
                <span class="speed-label" id="width-label">2 👆</span>
            </div>
            <span class="toolbar-label">Scroll Position</span>
            <div class="speed-control">
                <input type="range" id="scroll-slider" min="1" max="5" value="1" step="1">
                <span class="speed-label" id="scroll-label">1 (Top)</span>
            </div>
            <button class="play-btn" id="play-btn">▶ Play</button>
        </div>
    </div>
    
    <div id="container">
        <div id="reader-area">
            <div class="margin-handle margin-handle-left">
                <div class="margin-indicator"></div>
            </div>
            <div class="margin-handle margin-handle-right">
                <div class="margin-indicator"></div>
            </div>
            <div id="focus-indicator"></div>
            <div id="text-content">
                <h1>Chapter One: The Beginning</h1>
                <p>In the heart of Silicon Valley, where innovation breathed life into dreams and ambition fueled the relentless pursuit of progress, there existed a small startup that dared to challenge the giants. The morning sun cast long shadows through the floor-to-ceiling windows of their modest office, illuminating screens filled with code and whiteboards covered in sketches of impossible ideas.</p>
                <p>Sarah had always believed that the best products were born from frustration. It was a Tuesday afternoon when she threw her e-reader across the room—not hard enough to break it, but with enough force to express her complete dissatisfaction with the experience. "Why," she asked her co-founder Marcus, "does every reading app feel like it was designed in 2010?"</p>
                <p>Marcus looked up from his laptop, his fingers still hovering over the keyboard. He'd been wrestling with the same question for months. The reading experience hadn't evolved. Sure, screens got sharper and devices got thinner, but the fundamental interaction between human and text remained stubbornly unchanged.</p>
                <p>"What if," Sarah continued, pacing now, her mind racing ahead of her words, "we treated text like it was alive? What if reading could be as fluid and intuitive as touching water?"</p>
                <p>That conversation sparked something neither of them could ignore. Within weeks, they had assembled a small team of designers and developers who shared their vision. The goal was simple yet audacious: reimagine reading for the touch-screen era. Not just digital books, but a completely new way of interacting with text.</p>
                <p>The first prototype was rough—buggy gestures, inconsistent behavior, and a tendency to crash at the worst possible moments. But there was something there, something that felt right. When you pinched the screen and watched the text respond, growing larger or smaller with the natural motion of your fingers, it felt like magic. When you swept two fingers vertically and saw the lines of text breathe, expanding and contracting with your touch, it felt like the text was alive.</p>
                <p>They called it Project Phoenix, because they were resurrecting the reading experience from the ashes of stagnation. Every evening, the team would gather around a large display, testing gestures, debating interactions, and pushing the boundaries of what felt natural. Some ideas were brilliant; most were terrible. But each failure taught them something new about how humans wanted to interact with text.</p>
            </div>
        </div>
    </div>

    <script>
        // ==================== CONFIGURATION ====================
        const CONFIG = {
            style: {
                fontSize: { default: 18, min: 12, max: 48 },
                lineHeight: { default: 1.6 },
                margin: { default: 60, min: 10, max: 400 } // Increased max from 200 to 400
            },
            flow: {
                cursorWidth: 150,
                defaultSpeed: 300,
                minSpeed: 100,
                maxSpeed: 600,
                wordSpacing: 5,
                minWidth: 50,
                maxWidth: 400,
                newlinePauseMultiplier: 1.5 // Pause 1.5x longer at newlines
            },
            scroll: {
                comfortZoneTop: 0.15,
                comfortZoneBottom: 0.7,
                userScrollTimeout: 1500,
                defaultTargetPosition: 1,
                topGap: 0.1
            },
            focus: {
                minFingers: 1,
                maxFingers: 4,
                defaultFingers: 2,
                fingerWidthBase: 45
            }
        };

        // ==================== STATE MANAGEMENT ====================
        const state = {
            style: {
                fontSize: CONFIG.style.fontSize.default,
                lineHeight: CONFIG.style.lineHeight.default,
                marginLeft: CONFIG.style.margin.default,
                marginRight: CONFIG.style.margin.default,
                marginTop: 40,
                marginBottom: 40
            },
            flow: {
                isPlaying: false,
                speed: CONFIG.flow.defaultSpeed,
                cursorPosition: 0,
                currentWordIndex: 0, // Track current word index instead of just position
                startTime: 0,
                animationFrame: null,
                userScrolling: false,
                scrollTimeout: null,
                focusFingers: CONFIG.focus.defaultFingers,
                scrollTargetPosition: CONFIG.scroll.defaultTargetPosition,
                pausedAtNewline: false,
                newlinePauseStart: 0
            },
            mode: {
                current: 'normal',
                bionicEnabled: false,
                previousMode: 'normal',
                savedFlowState: null // Store flow state when switching modes
            },
            gesture: {
                touches: [],
                initialDistance: 0,
                initialFontSize: 0,
                isDraggingMargin: false,
                draggedHandle: null,
                initialMarginValue: 0,
                initialTouchX: 0
            }
        };

        // ==================== DOM REFERENCES ====================
        const DOM = {
            readerArea: document.getElementById('reader-area'),
            textContent: document.getElementById('text-content'),
            leftHandle: document.querySelector('.margin-handle-left'),
            rightHandle: document.querySelector('.margin-handle-right'),
            playBtn: document.getElementById('play-btn'),
            speedSlider: document.getElementById('speed-slider'),
            speedLabel: document.getElementById('speed-label'),
            widthSlider: document.getElementById('width-slider'),
            widthLabel: document.getElementById('width-label'),
            scrollSlider: document.getElementById('scroll-slider'),
            scrollLabel: document.getElementById('scroll-label'),
            bionicToggle: document.getElementById('bionic-toggle'),
            flowToggle: document.getElementById('flow-toggle'),
            flowControls: document.getElementById('flow-controls'),
            focusIndicator: document.getElementById('focus-indicator')
        };

        // ==================== ORIGINAL CONTENT ====================
        const ORIGINAL_TEXT = `
            <h1>Chapter One: The Beginning</h1>
            <p>In the heart of Silicon Valley, where innovation breathed life into dreams and ambition fueled the relentless pursuit of progress, there existed a small startup that dared to challenge the giants. The morning sun cast long shadows through the floor-to-ceiling windows of their modest office, illuminating screens filled with code and whiteboards covered in sketches of impossible ideas.</p>
            
            <p>Sarah had always believed that the best products were born from frustration. It was a Tuesday afternoon when she threw her e-reader across the room—not hard enough to break it, but with enough force to express her complete dissatisfaction with the experience. "Why," she asked her co-founder Marcus, "does every reading app feel like it was designed in 2010?"</p>
            
            <p>Marcus looked up from his laptop, his fingers still hovering over the keyboard. He'd been wrestling with the same question for months. The reading experience hadn't evolved. Sure, screens got sharper and devices got thinner, but the fundamental interaction between human and text remained stubbornly unchanged.</p>
            
            <p>"What if," Sarah continued, pacing now, her mind racing ahead of her words, "we treated text like it was alive? What if reading could be as fluid and intuitive as touching water?"</p>
            
            <p>That conversation sparked something neither of them could ignore. Within weeks, they had assembled a small team of designers and developers who shared their vision. The goal was simple yet audacious: reimagine reading for the touch-screen era. Not just digital books, but a completely new way of interacting with text.</p>
            
            <p>The first prototype was rough—buggy gestures, inconsistent behavior, and a tendency to crash at the worst possible moments. But there was something there, something that felt right. When you pinched the screen and watched the text respond, growing larger or smaller with the natural motion of your fingers, it felt like magic. When you swept two fingers vertically and saw the lines of text breathe, expanding and contracting with your touch, it felt like the text was alive.</p>
            
            <p>They called it Project Phoenix, because they were resurrecting the reading experience from the ashes of stagnation. Every evening, the team would gather around a large display, testing gestures, debating interactions, and pushing the boundaries of what felt natural. Some ideas were brilliant; most were terrible. But each failure taught them something new about how humans wanted to interact with text.</p>
        `;

        // ==================== UTILITY FUNCTIONS ====================
        function applyElasticResistance(value, min, max) {
            if (value < min) {
                const overflow = min - value;
                return min - Math.sqrt(overflow) * 2;
            } else if (value > max) {
                const overflow = value - max;
                return max + Math.sqrt(overflow) * 2;
            }
            return value;
        }

        function getDistance(touch1, touch2) {
            const dx = touch2.clientX - touch1.clientX;
            const dy = touch2.clientY - touch1.clientY;
            return Math.sqrt(dx * dx + dy * dy);
        }

        // ==================== WORD POSITION CALCULATOR ====================
        class WordPositionCalculator {
            static calculate() {
                const words = document.querySelectorAll('.flow-word[data-word-index]');
                const positions = [];
                
                words.forEach((word, index) => {
                    const rect = word.getBoundingClientRect();
                    const isNewline = word.dataset.isNewline === 'true';
                    positions.push({
                        element: word,
                        left: rect.left,
                        right: rect.right,
                        top: rect.top,
                        width: rect.width,
                        index: index,
                        isNewline: isNewline
                    });
                });
                
                return positions;
            }

            static calculateDistanceToWord(targetIndex, positions) {
                let distance = 0;
                for (let i = 0; i < targetIndex && i < positions.length; i++) {
                    distance += positions[i].width + CONFIG.flow.wordSpacing;
                }
                return distance;
            }

            static getTotalTextWidth(positions) {
                return positions.reduce((sum, pos) => 
                    sum + pos.width + CONFIG.flow.wordSpacing, 0
                );
            }
            
            static getWordIndexAtPosition(positions, distance) {
                let accumulated = 0;
                for (let i = 0; i < positions.length; i++) {
                    const wordEnd = accumulated + positions[i].width;
                    if (distance < wordEnd) {
                        return i;
                    }
                    accumulated = wordEnd + CONFIG.flow.wordSpacing;
                }
                return positions.length - 1;
            }
        }

        // ==================== TEXT FORMATTER ====================
        class TextFormatter {
            static makeBionicText(text) {
                return text.replace(/\b(\w+)\b/g, (word) => {
                    if (word.length <= 2) return word;
                    const boldCount = Math.ceil(word.length / 2);
                    const boldPart = word.slice(0, boldCount);
                    const normalPart = word.slice(boldCount);
                    return `<span class="bionic">${boldPart}</span>${normalPart}`;
                });
            }

            static makeFlowText(html, bionicEnabled) {
                const container = document.createElement('div');
                container.innerHTML = html;

                let wordCounter = 0;
                let previousTop = null;
                
                const wrapText = (text, parentElement) => {
                    return text.replace(/(\S+)/g, (item) => {
                        if (/\w/.test(item)) {
                            let content = item;
                            const wordOnly = item.match(/\w+/);
                            if (bionicEnabled && wordOnly && wordOnly[0].length > 2) {
                                const word = wordOnly[0];
                                const boldCount = Math.ceil(word.length / 2);
                                const boldPart = word.slice(0, boldCount);
                                const normalPart = word.slice(boldCount);
                                content = item.replace(word, `<span class="bionic">${boldPart}</span>${normalPart}`);
                            }
                            
                            // Create temporary span to check if it's on a new line
                            const tempSpan = document.createElement('span');
                            tempSpan.innerHTML = content;
                            tempSpan.style.position = 'absolute';
                            tempSpan.style.visibility = 'hidden';
                            if (parentElement) {
                                parentElement.appendChild(tempSpan);
                                const rect = tempSpan.getBoundingClientRect();
                                const isNewline = previousTop !== null && rect.top > previousTop + 5;
                                previousTop = rect.top;
                                parentElement.removeChild(tempSpan);
                                
                                return `<span class="flow-word inactive" data-word-index="${wordCounter++}" data-is-newline="${isNewline}">${content}</span>`;
                            }
                            
                            return `<span class="flow-word inactive" data-word-index="${wordCounter++}" data-is-newline="false">${content}</span>`;
                        } else {
                            return `<span class="flow-word inactive" data-word-index="${wordCounter++}" data-is-newline="false">${item}</span>`;
                        }
                    });
                };

                const processNode = (node, parentElement) => {
                    if (node.nodeType === Node.TEXT_NODE) {
                        const temp = document.createElement('span');
                        temp.innerHTML = wrapText(node.textContent, parentElement);
                        node.replaceWith(...temp.childNodes);
                    } else if (node.nodeType === Node.ELEMENT_NODE) {
                        [...node.childNodes].forEach(child => processNode(child, node));
                    }
                };

                [...container.childNodes].forEach(node => processNode(node, container));
                return container.innerHTML;
            }
        }

        // ==================== STYLE MANAGER ====================
        class StyleManager {
            static updateStyles() {
                const s = state.style;
                DOM.textContent.style.fontSize = s.fontSize + 'px';
                DOM.textContent.style.lineHeight = s.lineHeight;
                DOM.textContent.style.padding = 
                    `${s.marginTop}px ${s.marginRight}px ${s.marginBottom}px ${s.marginLeft}px`;
                
                this.updateHandlePositions();
                
                // Update focus indicator if in flow mode
                if (state.mode.current === 'flow') {
                    FocusIndicator.update();
                }
            }

            static updateHandlePositions() {
                const readerRect = DOM.readerArea.getBoundingClientRect();
                DOM.leftHandle.style.left = 
                    (readerRect.left + state.style.marginLeft - 25) + 'px';
                DOM.rightHandle.style.left = 
                    (readerRect.right - state.style.marginRight - 25) + 'px';
            }
        }

        // ==================== FOCUS INDICATOR ====================
        class FocusIndicator {
            static update() {
                if (state.mode.current !== 'flow') {
                    DOM.focusIndicator.classList.remove('visible');
                    return;
                }
                
                const words = document.querySelectorAll('.flow-word[data-word-index]');
                const activeWords = Array.from(words).filter(w => w.classList.contains('active'));
                
                if (activeWords.length === 0) {
                    DOM.focusIndicator.classList.remove('visible');
                    return;
                }
                
                // Group words by line (based on their top position)
                const wordsByLine = {};
                activeWords.forEach(word => {
                    const rect = word.getBoundingClientRect();
                    const lineKey = Math.round(rect.top);
                    if (!wordsByLine[lineKey]) {
                        wordsByLine[lineKey] = [];
                    }
                    wordsByLine[lineKey].push(rect);
                });
                
                // Get the line with the most words (primary line)
                let primaryLine = null;
                let maxWords = 0;
                for (const lineKey in wordsByLine) {
                    if (wordsByLine[lineKey].length > maxWords) {
                        maxWords = wordsByLine[lineKey].length;
                        primaryLine = lineKey;
                    }
                }
                
                // Use only the primary line for the indicator
                if (primaryLine) {
                    const rects = wordsByLine[primaryLine];
                    const minLeft = Math.min(...rects.map(r => r.left));
                    const maxRight = Math.max(...rects.map(r => r.right));
                    const minTop = Math.min(...rects.map(r => r.top));
                    const maxBottom = Math.max(...rects.map(r => r.bottom));
                    
                    const readerRect = DOM.readerArea.getBoundingClientRect();
                    
                    DOM.focusIndicator.style.left = (minLeft - readerRect.left) + 'px';
                    DOM.focusIndicator.style.width = (maxRight - minLeft) + 'px';
                    DOM.focusIndicator.style.top = (minTop - readerRect.top + DOM.readerArea.scrollTop) + 'px';
                    DOM.focusIndicator.style.height = (maxBottom - minTop) + 'px';
                    DOM.focusIndicator.classList.add('visible');
                }
            }
        }

        // ==================== SCROLL MANAGER ====================
        class ScrollManager {
            static getTargetPositionFromLevel(level) {
                const topGap = CONFIG.scroll.topGap;
                const increment = 0.2;
                return topGap + ((level - 1) * increment);
            }

            static gentlyScrollToWord(wordElement) {
                if (state.flow.userScrolling) return;

                const readerRect = DOM.readerArea.getBoundingClientRect();
                const wordRect = wordElement.getBoundingClientRect();
                
                const scrollTop = DOM.readerArea.scrollTop;
                const viewportHeight = readerRect.height;
                
                const targetPositionRatio = this.getTargetPositionFromLevel(state.flow.scrollTargetPosition);
                const targetViewportPosition = readerRect.top + viewportHeight * targetPositionRatio;
                
                const comfortZoneTop = readerRect.top + viewportHeight * CONFIG.scroll.comfortZoneTop;
                const comfortZoneBottom = readerRect.bottom - viewportHeight * CONFIG.scroll.comfortZoneBottom;
                
                let targetScroll = scrollTop;
                
                if (wordRect.top < comfortZoneTop || wordRect.bottom > comfortZoneBottom) {
                    const wordDistanceFromTop = wordRect.top - readerRect.top;
                    const desiredDistance = viewportHeight * targetPositionRatio;
                    targetScroll = scrollTop + (wordDistanceFromTop - desiredDistance);
                } else {
                    return;
                }
                
                DOM.readerArea.scrollTo({
                    top: targetScroll,
                    behavior: 'smooth'
                });
            }

            static handleUserScroll() {
                state.flow.userScrolling = true;
                clearTimeout(state.flow.scrollTimeout);
                state.flow.scrollTimeout = setTimeout(() => {
                    state.flow.userScrolling = false;
                }, CONFIG.scroll.userScrollTimeout);
            }

            static getScrollLevelLabel(level) {
                const labels = {
                    1: '1 (Top)',
                    2: '2 (Upper)',
                    3: '3 (Middle)',
                    4: '4 (Lower)',
                    5: '5 (Bottom)'
                };
                return labels[level] || level.toString();
            }
        }

        // ==================== FOCUS WIDTH CALCULATOR ====================
        class FocusWidthCalculator {
            static calculate(fingers) {
                const fontScale = state.style.fontSize / 18;
                return CONFIG.focus.fingerWidthBase * fingers * fontScale;
            }

            static getCurrentWidth() {
                return this.calculate(state.flow.focusFingers);
            }
        }

        // ==================== FLOW READER ====================
        class FlowReader {
            static start() {
                if (state.flow.isPlaying) return;
                
                state.flow.isPlaying = true;
                DOM.playBtn.textContent = '⏸ Pause';
                
                const wordPositions = WordPositionCalculator.calculate();
                if (wordPositions.length === 0) return;
                
                if (state.flow.cursorPosition === 0) {
                    state.flow.startTime = performance.now();
                    state.flow.currentWordIndex = 0;
                } else {
                    const avgCharWidth = state.style.fontSize * 0.5;
                    const pixelsPerSecond = (state.flow.speed / 60) * avgCharWidth * 6;
                    const elapsedTime = (state.flow.cursorPosition / pixelsPerSecond) * 1000;
                    state.flow.startTime = performance.now() - elapsedTime;
                }
                
                this.animate(wordPositions);
            }

            static stop() {
                if (state.flow.animationFrame) {
                    cancelAnimationFrame(state.flow.animationFrame);
                    state.flow.animationFrame = null;
                }
                state.flow.isPlaying = false;
                DOM.playBtn.textContent = '▶ Play';
            }

            static toggle() {
                if (state.flow.isPlaying) {
                    this.stop();
                } else {
                    this.start();
                }
            }

            static animate(wordPositions) {
                const animateFrame = (currentTime) => {
                    if (!state.flow.isPlaying) return;
                    
                    // Handle newline pause
                    if (state.flow.pausedAtNewline) {
                        const pauseDuration = (60000 / state.flow.speed) * CONFIG.flow.newlinePauseMultiplier;
                        const pauseElapsed = currentTime - state.flow.newlinePauseStart;
                        
                        if (pauseElapsed < pauseDuration) {
                            state.flow.animationFrame = requestAnimationFrame(animateFrame);
                            return;
                        } else {
                            state.flow.pausedAtNewline = false;
                            state.flow.startTime = currentTime - ((state.flow.cursorPosition / 
                                ((state.flow.speed / 60) * (state.style.fontSize * 0.5) * 6)) * 1000);
                        }
                    }
                    
                    const elapsed = currentTime - state.flow.startTime;
                    const avgCharWidth = state.style.fontSize * 0.5;
                    const pixelsPerSecond = (state.flow.speed / 60) * avgCharWidth * 6;
                    
                    const totalDistance = (elapsed / 1000) * pixelsPerSecond;
                    state.flow.cursorPosition = totalDistance;
                    
                    const words = document.querySelectorAll('.flow-word[data-word-index]');
                    words.forEach(w => {
                        w.classList.remove('active');
                        w.classList.add('inactive');
                    });
                    
                    let foundActive = false;
                    let lastActiveIndex = -1;
                    
                    for (let i = 0; i < wordPositions.length; i++) {
                        const pos = wordPositions[i];
                        
                        const wordStart = WordPositionCalculator.calculateDistanceToWord(i, wordPositions);
                        const wordEnd = wordStart + pos.width;
                        const cursorStart = totalDistance;
                        const cursorEnd = totalDistance + FocusWidthCalculator.getCurrentWidth();
                        
                        if (cursorEnd >= wordStart && cursorStart <= wordEnd) {
                            pos.element.classList.remove('inactive');
                            pos.element.classList.add('active');
                            lastActiveIndex = i;
                            
                            if (!foundActive) {
                                foundActive = true;
                                state.flow.currentWordIndex = i;
                                ScrollManager.gentlyScrollToWord(pos.element);
                                
                                // Check if this word starts a new line and we haven't paused yet
                                if (pos.isNewline && i > 0 && !state.flow.pausedAtNewline) {
                                    state.flow.pausedAtNewline = true;
                                    state.flow.newlinePauseStart = currentTime;
                                }
                            }
                        }
                    }
                    
                    // Update focus indicator
                    FocusIndicator.update();
                    
                    const totalTextWidth = WordPositionCalculator.getTotalTextWidth(wordPositions);
                    if (totalDistance > totalTextWidth + FocusWidthCalculator.getCurrentWidth()) {
                        state.flow.startTime = currentTime;
                        state.flow.cursorPosition = 0;
                        state.flow.currentWordIndex = 0;
                    }
                    
                    state.flow.animationFrame = requestAnimationFrame(animateFrame);
                };
                
                state.flow.animationFrame = requestAnimationFrame(animateFrame);
            }

            static jumpToWord(targetIndex) {
                const wordPositions = WordPositionCalculator.calculate();
                const distance = WordPositionCalculator.calculateDistanceToWord(targetIndex, wordPositions);
                
                state.flow.cursorPosition = distance;
                state.flow.currentWordIndex = targetIndex;
                
                const avgCharWidth = state.style.fontSize * 0.5;
                const pixelsPerSecond = (state.flow.speed / 60) * avgCharWidth * 6;
                const elapsedTime = (distance / pixelsPerSecond) * 1000;
                state.flow.startTime = performance.now() - elapsedTime;
                
                if (!state.flow.isPlaying) {
                    this.updateWordStates(wordPositions, distance);
                    FocusIndicator.update();
                }
            }

            static updateWordStates(wordPositions, cursorPosition) {
                const words = document.querySelectorAll('.flow-word[data-word-index]');
                words.forEach(w => {
                    w.classList.remove('active');
                    w.classList.add('inactive');
                });
                
                for (let i = 0; i < wordPositions.length; i++) {
                    const pos = wordPositions[i];
                    const wordStart = WordPositionCalculator.calculateDistanceToWord(i, wordPositions);
                    const wordEnd = wordStart + pos.width;
                    const cursorStart = cursorPosition;
                    const cursorEnd = cursorPosition + FocusWidthCalculator.getCurrentWidth();
                    
                    if (cursorEnd >= wordStart && cursorStart <= wordEnd) {
                        pos.element.classList.remove('inactive');
                        pos.element.classList.add('active');
                    }
                }
            }
            
            static recalibrateAfterLayoutChange() {
                // After font/margin changes, recalculate position based on current word index
                const wordPositions = WordPositionCalculator.calculate();
                if (wordPositions.length === 0) return;
                
                // Clamp word index to valid range
                state.flow.currentWordIndex = Math.min(
                    state.flow.currentWordIndex, 
                    wordPositions.length - 1
                );
                
                const distance = WordPositionCalculator.calculateDistanceToWord(
                    state.flow.currentWordIndex, 
                    wordPositions
                );
                
                state.flow.cursorPosition = distance;
                
                // Recalculate start time
                const avgCharWidth = state.style.fontSize * 0.5;
                const pixelsPerSecond = (state.flow.speed / 60) * avgCharWidth * 6;
                const elapsedTime = (distance / pixelsPerSecond) * 1000;
                state.flow.startTime = performance.now() - elapsedTime;
                
                if (!state.flow.isPlaying) {
                    this.updateWordStates(wordPositions, distance);
                }
                
                FocusIndicator.update();
            }
        }

        // ==================== MODE MANAGER ====================
        class ModeManager {
            static setMode(mode, preserveState = false) {
                const wasFlowPlaying = state.flow.isPlaying;
                
                // Save current flow state before switching
                if (state.mode.current === 'flow' && mode !== 'flow') {
                    state.mode.savedFlowState = {
                        cursorPosition: state.flow.cursorPosition,
                        currentWordIndex: state.flow.currentWordIndex,
                        isPlaying: wasFlowPlaying
                    };
                }
                
                state.mode.previousMode = state.mode.current;
                state.mode.current = mode;
                FlowReader.stop();
                
                DOM.flowToggle.classList.toggle('active', mode === 'flow');
                DOM.flowControls.style.display = mode === 'flow' ? 'flex' : 'none';
                
                this.renderContent();
                
                // Restore flow state if switching back to flow mode
                if (mode === 'flow' && state.mode.savedFlowState && preserveState) {
                    requestAnimationFrame(() => {
                        state.flow.currentWordIndex = state.mode.savedFlowState.currentWordIndex;
                        FlowReader.recalibrateAfterLayoutChange();
                        
                        if (state.mode.savedFlowState.isPlaying) {
                            setTimeout(() => FlowReader.start(), 100);
                        }
                    });
                } else if (mode === 'flow') {
                    // Show focus indicator even when paused
                    requestAnimationFrame(() => {
                        const wordPositions = WordPositionCalculator.calculate();
                        FlowReader.updateWordStates(wordPositions, state.flow.cursorPosition);
                        FocusIndicator.update();
                    });
                }
                
                if (mode !== 'flow') {
                    DOM.focusIndicator.classList.remove('visible');
                }
            }

            static renderContent() {
                let html = ORIGINAL_TEXT;
                
                // Add transition class for smooth bionic toggle
                DOM.textContent.classList.add('transitioning');
                
                if (state.mode.current === 'flow') {
                    html = TextFormatter.makeFlowText(html, state.mode.bionicEnabled);
                    if (!state.mode.savedFlowState) {
                        state.flow.cursorPosition = 0;
                        state.flow.currentWordIndex = 0;
                    }
                } else if (state.mode.bionicEnabled) {
                    html = TextFormatter.makeBionicText(html);
                }
                
                DOM.textContent.innerHTML = html;
                
                // Remove transition class after content update
                setTimeout(() => {
                    DOM.textContent.classList.remove('transitioning');
                }, 200);
                
                if (state.mode.current === 'flow') {
                    setTimeout(() => this.attachWordClickHandlers(), 0);
                }
            }

            static toggleFlow() {
                const newMode = state.mode.current === 'flow' ? 'normal' : 'flow';
                this.setMode(newMode, true); // Preserve state when toggling
            }

            static attachWordClickHandlers() {
                const newContent = DOM.textContent.cloneNode(true);
                DOM.textContent.parentNode.replaceChild(newContent, DOM.textContent);
                DOM.textContent = newContent;
                
                DOM.textContent.addEventListener('click', (e) => {
                    if (state.mode.current !== 'flow') return;
                    
                    const word = e.target.closest('.flow-word[data-word-index]');
                    if (word) {
                        const index = parseInt(word.dataset.wordIndex);
                        FlowReader.jumpToWord(index);
                    }
                });
            }

            static toggleBionic() {
                const wasFlowPlaying = state.flow.isPlaying;
                const savedCursorPosition = state.flow.cursorPosition;
                const savedWordIndex = state.flow.currentWordIndex;
                
                state.mode.bionicEnabled = !state.mode.bionicEnabled;
                DOM.bionicToggle.textContent = state.mode.bionicEnabled ? 'On' : 'Off';
                DOM.bionicToggle.classList.toggle('active', state.mode.bionicEnabled);
                
                if (wasFlowPlaying) {
                    FlowReader.stop();
                }
                
                this.renderContent();

                if (state.mode.current === 'flow') {
                    requestAnimationFrame(() => {
                        requestAnimationFrame(() => {
                            state.flow.currentWordIndex = savedWordIndex;
                            state.flow.cursorPosition = savedCursorPosition;
                            
                            FlowReader.recalibrateAfterLayoutChange();
                            
                            if (wasFlowPlaying) {
                                FlowReader.start();
                            }
                        });
                    });
                }
            }
        }

        // ==================== GESTURE HANDLER ====================
        class GestureHandler {
            static startDragMargin(e) {
                e.preventDefault();
                state.gesture.isDraggingMargin = true;
                state.gesture.draggedHandle = e.currentTarget;
                state.gesture.draggedHandle.classList.add('active');
                
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                state.gesture.initialTouchX = clientX;
                state.gesture.initialMarginValue = 
                    state.gesture.draggedHandle === DOM.leftHandle ? 
                    state.style.marginLeft : state.style.marginRight;
            }

            static handleDragMargin(e) {
                if (!state.gesture.isDraggingMargin) return;
                
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const delta = clientX - state.gesture.initialTouchX;
                
                let newValue;
                if (state.gesture.draggedHandle === DOM.leftHandle) {
                    newValue = state.gesture.initialMarginValue + delta;
                } else {
                    newValue = state.gesture.initialMarginValue - delta;
                }
                
                newValue = applyElasticResistance(
                    newValue, 
                    CONFIG.style.margin.min, 
                    CONFIG.style.margin.max
                );
                
                if (state.gesture.draggedHandle === DOM.leftHandle) {
                    state.style.marginLeft = newValue;
                } else {
                    state.style.marginRight = newValue;
                }
                
                StyleManager.updateStyles();
            }

            static stopDragMargin() {
                if (state.gesture.isDraggingMargin && state.gesture.draggedHandle) {
                    state.gesture.draggedHandle.classList.remove('active');
                    
                    const isLeft = state.gesture.draggedHandle === DOM.leftHandle;
                    const currentValue = isLeft ? 
                        state.style.marginLeft : state.style.marginRight;
                    
                    const finalValue = Math.max(
                        CONFIG.style.margin.min, 
                        Math.min(CONFIG.style.margin.max, currentValue)
                    );
                    
                    if (isLeft) {
                        state.style.marginLeft = finalValue;
                    } else {
                        state.style.marginRight = finalValue;
                    }
                    StyleManager.updateStyles();
                    
                    // Recalibrate flow if in flow mode
                    if (state.mode.current === 'flow') {
                        requestAnimationFrame(() => FlowReader.recalibrateAfterLayoutChange());
                    }
                }
                state.gesture.isDraggingMargin = false;
                state.gesture.draggedHandle = null;
            }

            static handleTouchStart(e) {
                if (state.gesture.isDraggingMargin) return;
                
                state.gesture.touches = Array.from(e.touches);
                
                if (state.gesture.touches.length === 2) {
                    e.preventDefault();
                    state.gesture.initialDistance = 
                        getDistance(state.gesture.touches[0], state.gesture.touches[1]);
                    state.gesture.initialFontSize = state.style.fontSize;
                }
            }

            static handleTouchMove(e) {
                if (state.gesture.isDraggingMargin) return;
                
                if (e.touches.length === 2) {
                    e.preventDefault();
                    const currentTouches = Array.from(e.touches);
                    const currentDistance = getDistance(currentTouches[0], currentTouches[1]);
                    
                    const distanceChange = Math.abs(currentDistance - state.gesture.initialDistance);
                    
                    const midpoint1X = (state.gesture.touches[0].clientX + state.gesture.touches[1].clientX) / 2;
                    const midpoint1Y = (state.gesture.touches[0].clientY + state.gesture.touches[1].clientY) / 2;
                    const midpoint2X = (currentTouches[0].clientX + currentTouches[1].clientX) / 2;
                    const midpoint2Y = (currentTouches[0].clientY + currentTouches[1].clientY) / 2;
                    const midpointDeltaX = Math.abs(midpoint2X - midpoint1X);
                    const midpointDeltaY = Math.abs(midpoint2Y - midpoint1Y);
                    
                    if (distanceChange > 10 && distanceChange > midpointDeltaX && distanceChange > midpointDeltaY) {
                        const scale = currentDistance / state.gesture.initialDistance;
                        state.style.fontSize = Math.max(
                            CONFIG.style.fontSize.min,
                            Math.min(CONFIG.style.fontSize.max, state.gesture.initialFontSize * scale)
                        );
                        StyleManager.updateStyles();
                    }
                }
            }
            
            static handleTouchEnd(e) {
                if (state.gesture.touches.length === 2 && state.mode.current === 'flow') {
                    // Recalibrate after pinch zoom
                    requestAnimationFrame(() => FlowReader.recalibrateAfterLayoutChange());
                }
            }

            static handleWheel(e) {
                if (e.ctrlKey || e.metaKey) {
                    e.preventDefault();
                    const wasPlaying = state.flow.isPlaying;
                    
                    state.style.fontSize = Math.max(
                        CONFIG.style.fontSize.min,
                        Math.min(CONFIG.style.fontSize.max, state.style.fontSize - e.deltaY * 0.1)
                    );
                    StyleManager.updateStyles();
                    
                    // Recalibrate flow after zoom
                    if (state.mode.current === 'flow') {
                        requestAnimationFrame(() => FlowReader.recalibrateAfterLayoutChange());
                    }
                }
            }
        }

        // ==================== EVENT LISTENERS ====================
        function initializeEventListeners() {
            DOM.leftHandle.addEventListener('mousedown', (e) => GestureHandler.startDragMargin(e));
            DOM.rightHandle.addEventListener('mousedown', (e) => GestureHandler.startDragMargin(e));
            DOM.leftHandle.addEventListener('touchstart', (e) => GestureHandler.startDragMargin(e));
            DOM.rightHandle.addEventListener('touchstart', (e) => GestureHandler.startDragMargin(e));

            document.addEventListener('mousemove', (e) => GestureHandler.handleDragMargin(e));
            document.addEventListener('touchmove', (e) => GestureHandler.handleDragMargin(e));
            document.addEventListener('mouseup', () => GestureHandler.stopDragMargin());
            document.addEventListener('touchend', () => {
                GestureHandler.stopDragMargin();
                GestureHandler.handleTouchEnd();
            });

            DOM.readerArea.addEventListener('touchstart', (e) => GestureHandler.handleTouchStart(e));
            DOM.readerArea.addEventListener('touchmove', (e) => GestureHandler.handleTouchMove(e));

            DOM.readerArea.addEventListener('wheel', (e) => GestureHandler.handleWheel(e));

            DOM.readerArea.addEventListener('scroll', () => ScrollManager.handleUserScroll());

            window.addEventListener('resize', () => {
                StyleManager.updateHandlePositions();
                if (state.mode.current === 'flow') {
                    requestAnimationFrame(() => FlowReader.recalibrateAfterLayoutChange());
                }
            });

            DOM.flowToggle.addEventListener('click', () => ModeManager.toggleFlow());

            DOM.bionicToggle.addEventListener('click', () => ModeManager.toggleBionic());

            DOM.playBtn.addEventListener('click', () => FlowReader.toggle());
            
            DOM.speedSlider.addEventListener('input', (e) => {
                const wasPlaying = state.flow.isPlaying;
                state.flow.speed = parseInt(e.target.value);
                DOM.speedLabel.textContent = state.flow.speed + ' wpm';
                
                // Recalibrate timing when speed changes
                if (state.mode.current === 'flow') {
                    FlowReader.recalibrateAfterLayoutChange();
                }
            });

            DOM.widthSlider.addEventListener('input', (e) => {
                state.flow.focusFingers = parseFloat(e.target.value);
                const fingerEmoji = state.flow.focusFingers === 1 ? '👆' : '👆'.repeat(Math.min(4, Math.ceil(state.flow.focusFingers)));
                DOM.widthLabel.textContent = state.flow.focusFingers + ' ' + fingerEmoji;
                
                // Update focus indicator immediately
                if (state.mode.current === 'flow') {
                    FocusIndicator.update();
                }
            });

            DOM.scrollSlider.addEventListener('input', (e) => {
                state.flow.scrollTargetPosition = parseInt(e.target.value);
                DOM.scrollLabel.textContent = ScrollManager.getScrollLevelLabel(state.flow.scrollTargetPosition);
            });
        }

        // ==================== INITIALIZATION ====================
        function initialize() {
            initializeEventListeners();
            ModeManager.setMode('normal');
            StyleManager.updateStyles();
        }

        initialize();
    </script>
</body>
</html>