<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EBookReader v2.0.0 - Separated Architecture</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        
        /* Test Results Panel */
        #test-results {
            position: fixed;
            top: 10px;
            right: 10px;
            background: white;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            padding: 15px;
            max-width: 350px;
            max-height: 500px;
            overflow-y: auto;
            z-index: 1000;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
            display: none;
        }

        #test-results.visible {
            display: block;
        }

        .test-header {
            font-weight: 600;
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 2px solid #e5e7eb;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .test-close {
            cursor: pointer;
            font-size: 18px;
            color: #666;
            padding: 0 5px;
        }

        .test-close:hover {
            color: #000;
        }

        .test-item {
            padding: 5px 0;
            font-size: 13px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .test-pass { color: #10b981; }
        .test-fail { color: #ef4444; }
        .test-summary {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 2px solid #e5e7eb;
            font-weight: 600;
        }
        
        /* Example UI Styles (NOT part of library) */
        .demo-toolbar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: #fff;
            border-bottom: 1px solid #e5e7eb;
            padding: 15px 20px;
            z-index: 300;
            box-shadow: 0 2px 8px rgba(0,0,0,.05);
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
        }

        .demo-btn {
            padding: 8px 16px;
            border: 2px solid #e5e7eb;
            background: #fff;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: all .2s;
        }

        .demo-btn:hover {
            border-color: #3b82f6;
            background: #f0f9ff;
        }

        .demo-btn.active {
            border-color: #3b82f6;
            background: #3b82f6;
            color: #fff;
        }

        .demo-control {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .demo-label {
            font-size: 12px;
            color: #666;
            font-weight: 600;
        }

        #reader-container {
            width: 100vw;
            height: 100vh;
            padding-top: 80px;
        }
    </style>
</head>
<body>
    <!-- Test Results Panel -->
    <div id="test-results"></div>
    
    <!-- External UI (NOT part of library) -->
    <div class="demo-toolbar">
        <button class="demo-btn" id="btn-bionic">Bionic Reading</button>
        <button class="demo-btn" id="btn-flow">Flow Mode</button>
        
        <div class="demo-control" id="flow-controls" style="display:none;">
            <span class="demo-label">Speed:</span>
            <input type="range" id="speed-slider" min="100" max="600" value="300" step="10">
            <span id="speed-label" class="demo-label">300 wpm</span>
            
            <span class="demo-label">Focus:</span>
            <input type="range" id="focus-slider" min="1" max="5" value="2" step="0.5">
            <span id="focus-label" class="demo-label">2</span>
            
            <span class="demo-label">Position:</span>
            <input type="range" id="scroll-slider" min="1" max="5" value="1" step="1">
            <span id="scroll-label" class="demo-label">Top</span>
            
            <button class="demo-btn" id="btn-play">â–¶ Play</button>
        </div>
    </div>

    <!-- Library only needs this container -->
    <div id="reader-container"></div>

    <script>
        /**
         * EBookReader Core Library v2.0.0
         * Pure reading functionality - NO UI components
         * 
         * @license MIT
         * @version 2.0.0
         */

        // ============================================================================
        // ERROR CLASSES
        // ============================================================================

        class EBookReaderError extends Error {
            constructor(message) {
                super(message);
                this.name = 'EBookReaderError';
            }
        }

        class ConfigurationError extends EBookReaderError {
            constructor(message) {
                super(message);
                this.name = 'ConfigurationError';
            }
        }

        class ContentError extends EBookReaderError {
            constructor(message) {
                super(message);
                this.name = 'ContentError';
            }
        }

        class StateError extends EBookReaderError {
            constructor(message) {
                super(message);
                this.name = 'StateError';
            }
        }

        // ============================================================================
        // WORD INDEX MANAGER
        // ============================================================================

        class WordIndexManager {
            constructor() {
                this.words = [];
                this.dirty = true;
            }

            rebuild() {
                try {
                    this.words = [];
                    const wordElements = document.querySelectorAll('.flow-word');
                    
                    if (!wordElements.length) {
                        this.dirty = false;
                        return;
                    }

                    let prevTop = -1;
                    wordElements.forEach((el, idx) => {
                        const rect = el.getBoundingClientRect();
                        const isNewline = prevTop !== -1 && rect.top > prevTop + 5;
                        
                        this.words.push({
                            el,
                            rect: {
                                left: rect.left,
                                right: rect.right,
                                top: rect.top,
                                bottom: rect.bottom,
                                width: rect.width,
                                height: rect.height
                            },
                            isNewline,
                            text: el.textContent,
                            index: idx
                        });
                        
                        prevTop = rect.top;
                    });
                    
                    this.dirty = false;
                } catch (error) {
                    throw new StateError(`Failed to rebuild word index: ${error.message}`);
                }
            }

            getWord(index) {
                if (typeof index !== 'number' || isNaN(index)) {
                    throw new TypeError('Word index must be a valid number');
                }
                
                if (this.dirty) this.rebuild();
                const idx = Math.floor(index);
                return this.words[idx] || null;
            }

            getActiveRange(centerIndex, focusWidth) {
                if (typeof centerIndex !== 'number' || isNaN(centerIndex)) {
                    throw new TypeError('Center index must be a valid number');
                }
                if (typeof focusWidth !== 'number' || focusWidth <= 0) {
                    throw new TypeError('Focus width must be a positive number');
                }
                
                if (this.dirty) this.rebuild();
                
                const centerIdx = Math.floor(centerIndex);
                const centerWord = this.words[centerIdx];
                
                if (!centerWord) return { start: 0, end: 0 };

                const centerTop = centerWord.rect.top;
                const halfWidth = focusWidth / 2;
                
                let start = Math.max(0, Math.round(centerIndex - halfWidth));
                let end = Math.min(this.words.length - 1, Math.round(centerIndex + halfWidth));

                while (start < centerIdx && this.words[start] && 
                       Math.abs(this.words[start].rect.top - centerTop) > 5) {
                    start++;
                }
                
                while (end > centerIdx && this.words[end] && 
                       Math.abs(this.words[end].rect.top - centerTop) > 5) {
                    end--;
                }

                return { start, end };
            }

            getTotalWords() {
                if (this.dirty) this.rebuild();
                return this.words.length;
            }

            invalidate() {
                this.dirty = true;
            }
        }

        // ============================================================================
        // CORE EBOOK READER (NO UI)
        // ============================================================================

        class EBookReader {
            static VERSION = '2.0.0';

            constructor(containerSelector, options = {}) {
                try {
                    this._validateConstructorArgs(containerSelector, options);
                    
                    this.config = {
                        fontSize: { min: 12, default: 18, max: 48 },
                        margin: { min: 10, default: 60, max: 400 },
                        speed: { min: 100, default: 300, max: 600 },
                        lineHeight: 1.6,
                        newlinePause: 1.5,
                        scroll: {
                            top: 0.15,
                            bottom: 0.7,
                            timeout: 1500,
                            gap: 0.1
                        }
                    };

                    this.state = {
                        fontSize: this._validateOption(options.fontSize, this.config.fontSize, 'fontSize'),
                        lineHeight: this.config.lineHeight,
                        marginL: this._validateOption(options.margin, this.config.margin, 'margin'),
                        marginR: this._validateOption(options.margin, this.config.margin, 'margin'),
                        marginTB: 40,
                        mode: 'normal',
                        bionic: false,
                        content: '',
                        flow: {
                            playing: false,
                            speed: this.config.speed.default,
                            currentWordIndex: 0,
                            startTime: 0,
                            rafId: null,
                            userScroll: false,
                            fingers: 2,
                            scrollLevel: 1,
                            pauseUntil: 0,
                            lastPausedWord: -1
                        },
                        gesture: {
                            touches: [],
                            initDist: 0,
                            initSize: 0,
                            dragging: false,
                            side: null,
                            initMargin: 0,
                            initX: 0
                        },
                        saved: null
                    };

                    // Event callbacks (external UI can subscribe)
                    this.callbacks = {
                        onModeChange: [],
                        onBionicChange: [],
                        onPlayChange: [],
                        onSpeedChange: [],
                        onStateChange: []
                    };

                    this.container = typeof containerSelector === 'string' 
                        ? document.querySelector(containerSelector) 
                        : containerSelector;
                    
                    if (!this.container) {
                        throw new ConfigurationError(
                            `Container element not found: "${containerSelector}"`
                        );
                    }

                    this.wordIndexManager = new WordIndexManager();
                    this._destroyed = false;
                    
                    // Bind event handlers so we can remove them later
                    this._resizeHandler = () => this.updateStyles();
                    this._scrollHandler = () => this._handleScroll();
                    
                    this._injectStyles();
                    this._buildDOM();
                    this._attachEventListeners();
                    
                    requestAnimationFrame(() => {
                        this.updateStyles();
                        // Initialize drag zone sizes
                        if (this.el.dragZoneL && this.el.dragZoneR && this.el.content) {
                            const contentHeight = this.el.content.scrollHeight;
                            const leftWidth = Math.max(60, this.state.marginL);
                            const rightWidth = Math.max(60, this.state.marginR);
                            
                            this.el.dragZoneL.style.width = leftWidth + 'px';
                            this.el.dragZoneL.style.height = contentHeight + 'px';
                            
                            this.el.dragZoneR.style.width = rightWidth + 'px';
                            this.el.dragZoneR.style.height = contentHeight + 'px';
                        }
                    });
                } catch (error) {
                    if (error instanceof EBookReaderError) {
                        throw error;
                    }
                    throw new ConfigurationError(`Failed to initialize: ${error.message}`);
                }
            }

            // ========================================
            // PUBLIC API (for external UI)
            // ========================================

            loadContent(html) {
                if (typeof html !== 'string') {
                    throw new ContentError(`Content must be a string`);
                }
                if (html.trim().length === 0) {
                    throw new ContentError('Content cannot be empty');
                }

                this.state.content = html;
                this._render();
            }

            setMode(mode) {
                if (mode !== 'normal' && mode !== 'flow') {
                    throw new Error('Mode must be "normal" or "flow"');
                }
                this._setMode(mode, true);
                this._emit('onModeChange', mode);
            }

            setBionic(enabled) {
                if (this.state.bionic !== enabled) {
                    this._toggleBionic();
                    this._emit('onBionicChange', enabled);
                }
            }

            setSpeed(wpm) {
                if (typeof wpm !== 'number' || wpm < this.config.speed.min || wpm > this.config.speed.max) {
                    throw new Error(`Speed must be between ${this.config.speed.min} and ${this.config.speed.max}`);
                }
                this.state.flow.speed = wpm;
                this._emit('onSpeedChange', wpm);
            }

            setFocusWidth(width) {
                if (typeof width !== 'number' || width < 1 || width > 5) {
                    throw new Error('Focus width must be between 1 and 5');
                }
                this.state.flow.fingers = width;
                if (this.state.mode === 'flow' && !this._destroyed && this.wordIndexManager) {
                    this._updateWordStates(this.state.flow.currentWordIndex);
                }
            }

            setScrollLevel(level) {
                if (typeof level !== 'number' || level < 1 || level > 5) {
                    throw new Error('Scroll level must be between 1 and 5');
                }
                this.state.flow.scrollLevel = level;
            }

            play() {
                if (!this.state.flow.playing && this.state.mode === 'flow') {
                    this._togglePlay();
                }
            }

            pause() {
                if (this.state.flow.playing) {
                    this._togglePlay();
                }
            }

            togglePlay() {
                if (this.state.mode === 'flow') {
                    this._togglePlay();
                }
            }

            jumpToWord(index) {
                if (this.state.mode === 'flow') {
                    this._jumpToWord(index);
                }
            }

            getState() {
                return {
                    version: EBookReader.VERSION,
                    mode: this.state.mode,
                    bionic: this.state.bionic,
                    fontSize: this.state.fontSize,
                    isPlaying: this.state.flow.playing,
                    currentWordIndex: this.state.flow.currentWordIndex,
                    totalWords: this.wordIndexManager ? this.wordIndexManager.getTotalWords() : 0,
                    speed: this.state.flow.speed,
                    focusWidth: this.state.flow.fingers,
                    scrollLevel: this.state.flow.scrollLevel
                };
            }

            on(event, callback) {
                if (this.callbacks[event]) {
                    this.callbacks[event].push(callback);
                }
            }

            off(event, callback) {
                if (this.callbacks[event]) {
                    this.callbacks[event] = this.callbacks[event].filter(cb => cb !== callback);
                }
            }

            destroy() {
                try {
                    // Stop any playing animation
                    if (this.state.flow.playing) {
                        cancelAnimationFrame(this.state.flow.rafId);
                    }
                    
                    // Remove event listeners to prevent errors after destroy
                    window.removeEventListener('resize', this._resizeHandler);
                    
                    if (this.el && this.el.reader) {
                        this.el.reader.removeEventListener('scroll', this._scrollHandler);
                    }
                    
                    // Clear container
                    if (this.container) {
                        this.container.innerHTML = '';
                    }
                    
                    // Mark as destroyed
                    this._destroyed = true;
                    this.wordIndexManager = null;
                } catch (error) {
                    throw new StateError(`Failed to destroy reader: ${error.message}`);
                }
            }

            // ========================================
            // PRIVATE METHODS
            // ========================================

            _emit(event, data) {
                if (this.callbacks[event]) {
                    this.callbacks[event].forEach(cb => cb(data));
                }
            }

            _validateConstructorArgs(containerSelector, options) {
                if (!containerSelector) {
                    throw new ConfigurationError('Container selector is required');
                }
                if (options && typeof options !== 'object') {
                    throw new ConfigurationError('Options must be an object');
                }
            }

            _validateOption(value, config, name) {
                if (value === undefined) return config.default;
                if (typeof value !== 'number' || isNaN(value)) {
                    throw new ConfigurationError(`${name} must be a valid number`);
                }
                if (value < config.min || value > config.max) {
                    console.warn(`${name} clamped to [${config.min}, ${config.max}]`);
                    return Math.max(config.min, Math.min(config.max, value));
                }
                return value;
            }

            _injectStyles() {
                if (document.getElementById('ebook-reader-styles')) return;

                const style = document.createElement('style');
                style.id = 'ebook-reader-styles';
                style.textContent = `
                    .ebook-reader-root {
                        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                        background: #f5f5f5;
                        overflow: hidden;
                        touch-action: none;
                        width: 100%;
                        height: 100%;
                        display: flex;
                        justify-content: center;
                        align-items: center;
                    }
                    .ebook-reader-area {
                        position: relative;
                        background: #fff;
                        box-shadow: 0 4px 20px rgba(0,0,0,.1);
                        overflow-y: auto;
                        transition: all .1s ease-out;
                        max-height: 85vh;
                    }
                    .ebook-drag-zone {
                        position: absolute;
                        top: 0;
                        height: 100%;
                        cursor: ew-resize;
                        z-index: 100;
                        transition: background .2s, border-color .2s;
                        border: 1px dashed transparent;
                        pointer-events: auto;
                    }
                    .ebook-drag-zone-left {
                        left: 0;
                    }
                    .ebook-drag-zone-right {
                        right: 0;
                    }
                    .ebook-drag-zone:hover {
                        background: rgba(59, 130, 246, 0.08);
                        border-color: rgba(59, 130, 246, 0.2);
                    }
                    .ebook-drag-zone.active {
                        background: rgba(59, 130, 246, 0.15);
                        border-color: rgba(59, 130, 246, 0.4);
                    }
                    .ebook-text-content {
                        transition: padding .1s ease-out, opacity .2s ease-in-out;
                        position: relative;
                        min-height: 100%;
                    }
                    .ebook-text-content.transitioning { opacity: .4; }
                    .bionic { font-weight: 700; }
                    .flow-word {
                        font-weight: 400;
                        cursor: pointer;
                        display: inline;
                        position: relative;
                    }
                    .flow-word:hover { opacity: .7; }
                    .flow-word.active {
                        opacity: 1;
                        color: #1a1a1a;
                    }
                    .flow-word.inactive { opacity: .2; }
                    .ebook-focus-indicator {
                        position: absolute;
                        top: 0;
                        left: 0;
                        pointer-events: none;
                        z-index: 50;
                        background: rgba(59,130,246,.08);
                        display: none;
                        border-radius: 3px;
                    }
                    .ebook-focus-indicator.visible { display: block; }
                `;
                document.head.appendChild(style);
            }

            _buildDOM() {
                this.container.innerHTML = '';
                this.container.className = 'ebook-reader-root';

                const html = `
                    <div class="ebook-reader-area">
                        <div class="ebook-drag-zone ebook-drag-zone-left" style="width: 60px;"></div>
                        <div class="ebook-drag-zone ebook-drag-zone-right" style="width: 60px;"></div>
                        <div class="ebook-focus-indicator"></div>
                        <div class="ebook-text-content"></div>
                    </div>
                `;

                this.container.innerHTML = html;

                this.el = {
                    reader: this.container.querySelector('.ebook-reader-area'),
                    content: this.container.querySelector('.ebook-text-content'),
                    dragZoneL: this.container.querySelector('.ebook-drag-zone-left'),
                    dragZoneR: this.container.querySelector('.ebook-drag-zone-right'),
                    focus: this.container.querySelector('.ebook-focus-indicator')
                };
            }

            _attachEventListeners() {
                ['mousedown', 'touchstart'].forEach(evt => {
                    this.el.dragZoneL.addEventListener(evt, e => this._startMarginDrag(e, 'left'));
                    this.el.dragZoneR.addEventListener(evt, e => this._startMarginDrag(e, 'right'));
                });

                ['mousemove', 'touchmove'].forEach(evt => {
                    document.addEventListener(evt, e => this._handleMarginDrag(e));
                });

                ['mouseup', 'touchend'].forEach(evt => {
                    document.addEventListener(evt, () => this._stopMarginDrag());
                });

                this.el.reader.addEventListener('touchstart', e => this._handleTouchStart(e));
                this.el.reader.addEventListener('touchmove', e => this._handleTouchMove(e));
                this.el.reader.addEventListener('wheel', e => this._handleWheel(e));
                this.el.reader.addEventListener('scroll', this._scrollHandler);

                window.addEventListener('resize', this._resizeHandler);
            }

            updateStyles() {
                if (this._destroyed || !this.el || !this.el.content) return;
                
                this.el.content.style.cssText = `
                    font-size: ${this.state.fontSize}px;
                    line-height: ${this.state.lineHeight};
                    padding: ${this.state.marginTB}px ${this.state.marginR}px ${this.state.marginTB}px ${this.state.marginL}px;
                `;

                // Update drag zone widths and heights to match content
                const leftWidth = Math.max(60, this.state.marginL);
                const rightWidth = Math.max(60, this.state.marginR);
                
                // Get full content height including scrollable area
                const contentHeight = this.el.content.scrollHeight;
                
                this.el.dragZoneL.style.width = leftWidth + 'px';
                this.el.dragZoneL.style.height = contentHeight + 'px';
                
                this.el.dragZoneR.style.width = rightWidth + 'px';
                this.el.dragZoneR.style.height = contentHeight + 'px';

                if (this.state.mode === 'flow' && this.wordIndexManager) {
                    this.wordIndexManager.invalidate();
                    requestAnimationFrame(() => {
                        if (!this._destroyed && this.wordIndexManager) {
                            this._updateWordStates(this.state.flow.currentWordIndex);
                        }
                    });
                }
            }

            _render() {
                if (this._destroyed || !this.el || !this.el.content) return;
                
                this.el.content.classList.add('transitioning');
                
                let html = this.state.content;
                if (this.state.mode === 'flow') {
                    html = this._makeFlow(html, this.state.bionic);
                    if (!this.state.saved) {
                        this.state.flow.currentWordIndex = 0;
                    }
                } else if (this.state.bionic) {
                    html = this._makeBionic(html);
                }

                this.el.content.innerHTML = html;
                
                if (this.wordIndexManager) {
                    this.wordIndexManager.invalidate();
                }

                setTimeout(() => {
                    if (!this._destroyed && this.el && this.el.content) {
                        this.el.content.classList.remove('transitioning');
                        
                        // Update drag zone heights after content renders
                        const contentHeight = this.el.content.scrollHeight;
                        if (this.el.dragZoneL && this.el.dragZoneR) {
                            this.el.dragZoneL.style.height = contentHeight + 'px';
                            this.el.dragZoneR.style.height = contentHeight + 'px';
                        }
                    }
                }, 200);

                if (this.state.mode === 'flow') {
                    setTimeout(() => {
                        if (this._destroyed || !this.el || !this.el.content || !this.wordIndexManager) return;
                        
                        this.el.content.querySelectorAll('.flow-word').forEach((w, idx) => {
                            w.addEventListener('click', () => {
                                if (this.state.mode === 'flow' && !this._destroyed) this._jumpToWord(idx);
                            });
                        });
                        
                        this.wordIndexManager.rebuild();
                    }, 50);
                }
            }

            _bionicWord(w) {
                if (w.length <= 2) return w;
                const n = Math.ceil(w.length / 2);
                return `<span class="bionic">${w.slice(0, n)}</span>${w.slice(n)}`;
            }

            _makeBionic(text) {
                return text.replace(/\b(\w+)\b/g, this._bionicWord.bind(this));
            }

            _makeFlow(html, useBionic) {
                const temp = document.createElement('div');
                temp.innerHTML = html;

                const wrap = text => text.replace(/(\S+)/g, word => {
                    const parts = word.match(/[^-]+-?/g) || [word];
                    
                    return parts.map(part => {
                        let content = part;
                        if (useBionic && /\w{3,}/.test(part)) {
                            const match = part.match(/\w+/);
                            if (match) {
                                content = part.replace(match[0], this._bionicWord(match[0]));
                            }
                        }
                        return `<span class="flow-word inactive">${content}</span>`;
                    }).join('');
                });

                const process = node => {
                    if (node.nodeType === 3) {
                        const t = document.createElement('span');
                        t.innerHTML = wrap(node.textContent);
                        node.replaceWith(...t.childNodes);
                    } else if (node.nodeType === 1) {
                        [...node.childNodes].forEach(process);
                    }
                };

                [...temp.childNodes].forEach(process);
                return temp.innerHTML;
            }

            _updateWordStates(centerIndex) {
                if (this._destroyed || !this.wordIndexManager || !this.el || !this.el.content) return;
                
                this.el.content.querySelectorAll('.flow-word').forEach(w => {
                    w.className = 'flow-word inactive';
                });

                const focusWidth = this.state.flow.fingers;
                const range = this.wordIndexManager.getActiveRange(centerIndex, focusWidth);
                
                const activeElements = [];
                for (let i = range.start; i <= range.end; i++) {
                    const word = this.wordIndexManager.getWord(i);
                    if (word && word.el) {
                        word.el.classList.remove('inactive');
                        word.el.classList.add('active');
                        activeElements.push(word.el);
                    }
                }

                if (this.state.mode !== 'flow' || activeElements.length === 0) {
                    this.el.focus.classList.remove('visible');
                    return;
                }

                const activeRects = activeElements.map(el => el.getBoundingClientRect());
                const byLine = {};
                activeRects.forEach(r => {
                    const k = Math.round(r.top);
                    (byLine[k] = byLine[k] || []).push(r);
                });

                const primary = Object.values(byLine).sort((a, b) => b.length - a.length)[0];
                if (!primary) {
                    this.el.focus.classList.remove('visible');
                    return;
                }

                const minL = Math.min(...primary.map(r => r.left));
                const maxR = Math.max(...primary.map(r => r.right));
                const minT = Math.min(...primary.map(r => r.top));
                const maxB = Math.max(...primary.map(r => r.bottom));

                const rr = this.el.reader.getBoundingClientRect();
                this.el.focus.style.cssText = `
                    left: ${minL - rr.left}px;
                    width: ${maxR - minL}px;
                    top: ${minT - rr.top + this.el.reader.scrollTop}px;
                    height: ${maxB - minT}px;
                `;
                this.el.focus.classList.add('visible');
            }

            _scrollToWord(wordIndex, instant = false) {
                if (this._destroyed || !this.wordIndexManager || this.state.flow.userScroll) return;

                const word = this.wordIndexManager.getWord(wordIndex);
                if (!word) return;

                const rr = this.el.reader.getBoundingClientRect();
                const vhh = rr.height;
                const target = this.config.scroll.gap + (this.state.flow.scrollLevel - 1) * 0.2;

                const comfortT = rr.top + vhh * this.config.scroll.top;
                const comfortB = rr.bottom - vhh * this.config.scroll.bottom;

                const currentRect = word.el.getBoundingClientRect();
                if (currentRect.top >= comfortT && currentRect.bottom <= comfortB) return;

                this.el.reader.scrollTo({
                    top: this.el.reader.scrollTop + (currentRect.top - rr.top) - (vhh * target),
                    behavior: instant ? 'auto' : 'smooth'
                });
            }

            _animate() {
                const frame = (t) => {
                    if (!this.state.flow.playing || this._destroyed || !this.wordIndexManager) return;

                    if (this.state.flow.pauseUntil > 0) {
                        if (t < this.state.flow.pauseUntil) {
                            this.state.flow.rafId = requestAnimationFrame(frame);
                            return;
                        }
                        this.state.flow.startTime = t - (this.state.flow.currentWordIndex / (this.state.flow.speed / 60)) * 1000;
                        this.state.flow.pauseUntil = 0;
                    }

                    const elapsed = t - this.state.flow.startTime;
                    const wordsPerSecond = this.state.flow.speed / 60;
                    const wordIndex = (elapsed / 1000) * wordsPerSecond;

                    this.state.flow.currentWordIndex = wordIndex;

                    const totalWords = this.wordIndexManager.getTotalWords();
                    if (wordIndex >= totalWords) {
                        this.state.flow.currentWordIndex = 0;
                        this.state.flow.startTime = t;
                        this.state.flow.pauseUntil = 0;
                        this.state.flow.lastPausedWord = -1;
                    }

                    const currentWordIdx = Math.floor(wordIndex);
                    const currentWord = this.wordIndexManager.getWord(currentWordIdx);

                    if (currentWord && currentWord.isNewline && this.state.flow.pauseUntil === 0) {
                        this._scrollToWord(currentWordIdx, true);
                    }

                    this._updateWordStates(this.state.flow.currentWordIndex);

                    if (currentWord && currentWord.isNewline && 
                        this.state.flow.pauseUntil === 0 && 
                        this.state.flow.lastPausedWord !== currentWordIdx) {
                        const pauseDuration = (60000 / this.state.flow.speed) * this.config.newlinePause;
                        this.state.flow.pauseUntil = t + pauseDuration;
                        this.state.flow.lastPausedWord = currentWordIdx;
                    }

                    if (!currentWord || !currentWord.isNewline) {
                        this._scrollToWord(currentWordIdx);
                    }

                    this.state.flow.rafId = requestAnimationFrame(frame);
                };

                this.state.flow.rafId = requestAnimationFrame(frame);
            }

            _togglePlay() {
                if (this._destroyed || !this.wordIndexManager) return;
                
                if (this.state.flow.playing) {
                    cancelAnimationFrame(this.state.flow.rafId);
                    this.state.flow.playing = false;
                } else {
                    this.wordIndexManager.rebuild();
                    const totalWords = this.wordIndexManager.getTotalWords();
                    if (!totalWords) return;

                    this.state.flow.playing = true;
                    
                    const wordsPerSecond = this.state.flow.speed / 60;
                    this.state.flow.startTime = performance.now() - 
                        (this.state.flow.currentWordIndex / wordsPerSecond) * 1000;
                    this.state.flow.pauseUntil = 0;
                    this.state.flow.lastPausedWord = -1;
                    
                    this._animate();
                }
                this._emit('onPlayChange', this.state.flow.playing);
            }

            _jumpToWord(idx) {
                if (this._destroyed || !this.wordIndexManager) return;
                
                this.state.flow.currentWordIndex = idx;
                if (!this.state.flow.playing) {
                    this._updateWordStates(idx);
                    this._scrollToWord(idx);
                } else {
                    const wordsPerSecond = this.state.flow.speed / 60;
                    this.state.flow.startTime = performance.now() - (idx / wordsPerSecond) * 1000;
                    this.state.flow.pauseUntil = 0;
                    this.state.flow.lastPausedWord = -1;
                    this._updateWordStates(idx);
                    this._scrollToWord(idx, true);
                }
            }

            _setMode(mode, preserve = false) {
                if (this._destroyed) return;
                
                const wasPlaying = this.state.flow.playing;
                
                if (this.state.mode === 'flow' && mode !== 'flow') {
                    this.state.saved = {
                        wordIndex: this.state.flow.currentWordIndex,
                        playing: wasPlaying
                    };
                }

                this.state.mode = mode;
                
                if (this.state.flow.playing) this._togglePlay();

                this._render();

                if (mode === 'flow' && this.state.saved && preserve) {
                    setTimeout(() => {
                        if (this._destroyed || !this.wordIndexManager) return;
                        
                        this.state.flow.currentWordIndex = this.state.saved.wordIndex || 0;
                        this._updateWordStates(this.state.flow.currentWordIndex);
                        if (this.state.saved.playing) {
                            setTimeout(() => {
                                if (!this._destroyed && this.wordIndexManager) this._togglePlay();
                            }, 100);
                        }
                    }, 100);
                } else if (mode === 'flow') {
                    setTimeout(() => {
                        if (!this._destroyed && this.wordIndexManager) {
                            this._updateWordStates(this.state.flow.currentWordIndex);
                        }
                    }, 100);
                }

                if (mode !== 'flow') {
                    this.el.focus.classList.remove('visible');
                }
            }

            _toggleBionic() {
                if (this._destroyed) return;
                
                const wasPlaying = this.state.flow.playing;
                const savedIdx = this.state.flow.currentWordIndex;
                
                this.state.bionic = !this.state.bionic;
                
                if (wasPlaying) this._togglePlay();
                
                this._render();
                
                if (this.state.mode === 'flow') {
                    setTimeout(() => {
                        if (this._destroyed || !this.wordIndexManager) return;
                        
                        this.state.flow.currentWordIndex = savedIdx;
                        this._updateWordStates(savedIdx);
                        if (wasPlaying) {
                            setTimeout(() => {
                                if (!this._destroyed && this.wordIndexManager) this._togglePlay();
                            }, 100);
                        }
                    }, 100);
                }
            }

            _startMarginDrag(e, side) {
                e.preventDefault();
                this.state.gesture.dragging = true;
                this.state.gesture.side = side;
                
                const zone = side === 'left' ? this.el.dragZoneL : this.el.dragZoneR;
                zone.classList.add('active');

                const x = e.touches?.[0]?.clientX || e.clientX;
                this.state.gesture.initX = x;
                this.state.gesture.initMargin = side === 'left' ? this.state.marginL : this.state.marginR;
            }

            _handleMarginDrag(e) {
                if (!this.state.gesture.dragging) return;

                const x = e.touches?.[0]?.clientX || e.clientX;
                const delta = x - this.state.gesture.initX;
                
                let val = this.state.gesture.initMargin + 
                    (this.state.gesture.side === 'left' ? delta : -delta);
                val = this._elastic(val, this.config.margin.min, this.config.margin.max);

                const contentHeight = this.el.content.scrollHeight;

                if (this.state.gesture.side === 'left') {
                    this.state.marginL = val;
                    // Update drag zone dimensions in real-time
                    this.el.dragZoneL.style.width = Math.max(60, val) + 'px';
                    this.el.dragZoneL.style.height = contentHeight + 'px';
                } else {
                    this.state.marginR = val;
                    // Update drag zone dimensions in real-time
                    this.el.dragZoneR.style.width = Math.max(60, val) + 'px';
                    this.el.dragZoneR.style.height = contentHeight + 'px';
                }
                
                this.updateStyles();
            }

            _stopMarginDrag() {
                if (this.state.gesture.dragging) {
                    const zone = this.state.gesture.side === 'left' ? this.el.dragZoneL : this.el.dragZoneR;
                    if (zone) zone.classList.remove('active');
                    
                    const isLeft = this.state.gesture.side === 'left';
                    const cur = isLeft ? this.state.marginL : this.state.marginR;
                    const final = this._clamp(cur, this.config.margin.min, this.config.margin.max);
                    const contentHeight = this.el.content.scrollHeight;
                    
                    if (isLeft) {
                        this.state.marginL = final;
                        this.el.dragZoneL.style.width = Math.max(60, final) + 'px';
                        this.el.dragZoneL.style.height = contentHeight + 'px';
                    } else {
                        this.state.marginR = final;
                        this.el.dragZoneR.style.width = Math.max(60, final) + 'px';
                        this.el.dragZoneR.style.height = contentHeight + 'px';
                    }
                    
                    this.updateStyles();
                }
                
                this.state.gesture.dragging = false;
                this.state.gesture.side = null;
            }

            _handleTouchStart(e) {
                if (this.state.gesture.dragging) return;
                this.state.gesture.touches = [...e.touches];
                
                if (e.touches.length === 2) {
                    e.preventDefault();
                    this.state.gesture.initDist = this._dist(e.touches[0], e.touches[1]);
                    this.state.gesture.initSize = this.state.fontSize;
                }
            }

            _handleTouchMove(e) {
                if (this.state.gesture.dragging || e.touches.length !== 2) return;
                e.preventDefault();

                const curDist = this._dist(e.touches[0], e.touches[1]);
                const distChange = Math.abs(curDist - this.state.gesture.initDist);

                const mid1 = {
                    x: (this.state.gesture.touches[0].clientX + this.state.gesture.touches[1].clientX) / 2,
                    y: (this.state.gesture.touches[0].clientY + this.state.gesture.touches[1].clientY) / 2
                };
                const mid2 = {
                    x: (e.touches[0].clientX + e.touches[1].clientX) / 2,
                    y: (e.touches[0].clientY + e.touches[1].clientY) / 2
                };
                const midDelta = {
                    x: Math.abs(mid2.x - mid1.x),
                    y: Math.abs(mid2.y - mid1.y)
                };

                if (distChange > 10 && distChange > midDelta.x && distChange > midDelta.y) {
                    const scale = curDist / this.state.gesture.initDist;
                    this.state.fontSize = this._clamp(
                        this.state.gesture.initSize * scale,
                        this.config.fontSize.min,
                        this.config.fontSize.max
                    );
                    this.updateStyles();
                }
            }

            _handleWheel(e) {
                if (e.ctrlKey || e.metaKey) {
                    e.preventDefault();
                    this.state.fontSize = this._clamp(
                        this.state.fontSize - e.deltaY * 0.1,
                        this.config.fontSize.min,
                        this.config.fontSize.max
                    );
                    this.updateStyles();
                }
            }

            _handleScroll() {
                this.state.flow.userScroll = true;
                clearTimeout(this._scrollTimeout);
                this._scrollTimeout = setTimeout(() => {
                    this.state.flow.userScroll = false;
                }, this.config.scroll.timeout);
            }

            _clamp(v, min, max) {
                return Math.max(min, Math.min(max, v));
            }

            _elastic(v, min, max) {
                return v < min ? min - Math.sqrt(min - v) * 2 :
                       v > max ? max + Math.sqrt(v - max) * 2 : v;
            }

            _dist(t1, t2) {
                return Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY);
            }
        }

        // ============================================================================
        // EXPOSE LIBRARY
        // ============================================================================

        window.EBookReader = EBookReader;
        window.EBookReaderError = EBookReaderError;
        window.ConfigurationError = ConfigurationError;
        window.ContentError = ContentError;
        window.StateError = StateError;

        // ============================================================================
        // TEST SUITE
        // ============================================================================

        class EBookReaderTestSuite {
            constructor() {
                this.tests = [];
                this.passed = 0;
                this.failed = 0;
            }

            test(name, fn) {
                this.tests.push({ name, fn });
            }

            async run() {
                const results = [];
                
                for (const { name, fn } of this.tests) {
                    try {
                        await fn();
                        this.passed++;
                        results.push({ name, passed: true });
                    } catch (error) {
                        this.failed++;
                        results.push({ name, passed: false, error: error.message });
                    }
                }

                return results;
            }

            assert(condition, message) {
                if (!condition) {
                    throw new Error(message || 'Assertion failed');
                }
            }

            assertEqual(actual, expected, message) {
                if (actual !== expected) {
                    throw new Error(message || `Expected ${expected}, got ${actual}`);
                }
            }

            assertThrows(fn, errorType, message) {
                let threw = false;
                try {
                    fn();
                } catch (error) {
                    threw = true;
                    if (errorType && !(error instanceof errorType)) {
                        throw new Error(message || `Expected ${errorType.name}, got ${error.constructor.name}`);
                    }
                }
                if (!threw) {
                    throw new Error(message || 'Expected function to throw');
                }
            }
        }

        async function runTests() {
            const suite = new EBookReaderTestSuite();

            // Helper to wait for pending operations
            const waitForPending = () => new Promise(resolve => setTimeout(resolve, 150));

            // ========================================
            // INITIALIZATION TESTS
            // ========================================

            suite.test('Library has version number', () => {
                suite.assertEqual(EBookReader.VERSION, '2.0.0', 'Version should be 2.0.0');
            });

            suite.test('Constructor requires container', () => {
                suite.assertThrows(
                    () => new EBookReader(null),
                    ConfigurationError,
                    'Should throw ConfigurationError for null container'
                );
            });

            suite.test('Constructor fails with invalid selector', () => {
                suite.assertThrows(
                    () => new EBookReader('#nonexistent-element'),
                    ConfigurationError,
                    'Should throw ConfigurationError for missing element'
                );
            });

            suite.test('Constructor accepts custom options', async () => {
                const testContainer = document.createElement('div');
                document.body.appendChild(testContainer);
                const reader = new EBookReader(testContainer, { fontSize: 20, margin: 80 });
                
                suite.assertEqual(reader.state.fontSize, 20, 'Custom fontSize should be applied');
                suite.assertEqual(reader.state.marginL, 80, 'Custom margin should be applied');
                
                reader.destroy();
                document.body.removeChild(testContainer);
                await waitForPending();
            });

            // ========================================
            // CONTENT LOADING TESTS
            // ========================================

            suite.test('loadContent validates input', async () => {
                const testContainer = document.createElement('div');
                document.body.appendChild(testContainer);
                const reader = new EBookReader(testContainer);
                
                suite.assertThrows(
                    () => reader.loadContent(''),
                    ContentError,
                    'Should throw ContentError for empty content'
                );
                
                suite.assertThrows(
                    () => reader.loadContent(123),
                    ContentError,
                    'Should throw ContentError for non-string content'
                );
                
                reader.destroy();
                document.body.removeChild(testContainer);
                await waitForPending();
            });

            suite.test('Content loads and renders', async () => {
                const testContainer = document.createElement('div');
                document.body.appendChild(testContainer);
                const reader = new EBookReader(testContainer);
                
                reader.loadContent('<p>Test content here</p>');
                suite.assert(reader.state.content.includes('Test content here'), 'Content should be stored');
                
                reader.destroy();
                document.body.removeChild(testContainer);
                await waitForPending();
            });

            // ========================================
            // PUBLIC API TESTS
            // ========================================

            suite.test('setMode() changes mode', async () => {
                const testContainer = document.createElement('div');
                document.body.appendChild(testContainer);
                const reader = new EBookReader(testContainer);
                
                reader.loadContent('<p>Test</p>');
                reader.setMode('flow');
                
                suite.assertEqual(reader.getState().mode, 'flow', 'Mode should be flow');
                
                reader.setMode('normal');
                suite.assertEqual(reader.getState().mode, 'normal', 'Mode should be normal');
                
                reader.destroy();
                document.body.removeChild(testContainer);
                await waitForPending();
            });

            suite.test('setBionic() toggles bionic mode', async () => {
                const testContainer = document.createElement('div');
                document.body.appendChild(testContainer);
                const reader = new EBookReader(testContainer);
                
                reader.loadContent('<p>Test</p>');
                
                suite.assertEqual(reader.getState().bionic, false, 'Should start disabled');
                
                reader.setBionic(true);
                suite.assertEqual(reader.getState().bionic, true, 'Should be enabled');
                
                reader.setBionic(false);
                suite.assertEqual(reader.getState().bionic, false, 'Should be disabled');
                
                reader.destroy();
                document.body.removeChild(testContainer);
                await waitForPending();
            });

            suite.test('setSpeed() changes speed', async () => {
                const testContainer = document.createElement('div');
                document.body.appendChild(testContainer);
                const reader = new EBookReader(testContainer);
                
                reader.setSpeed(450);
                suite.assertEqual(reader.getState().speed, 450, 'Speed should be 450');
                
                reader.destroy();
                document.body.removeChild(testContainer);
                await waitForPending();
            });

            suite.test('setFocusWidth() changes focus width', async () => {
                const testContainer = document.createElement('div');
                document.body.appendChild(testContainer);
                const reader = new EBookReader(testContainer);
                
                reader.setFocusWidth(3);
                suite.assertEqual(reader.getState().focusWidth, 3, 'Focus width should be 3');
                
                reader.destroy();
                document.body.removeChild(testContainer);
                await waitForPending();
            });

            suite.test('setScrollLevel() changes scroll position', async () => {
                const testContainer = document.createElement('div');
                document.body.appendChild(testContainer);
                const reader = new EBookReader(testContainer);
                
                reader.setScrollLevel(3);
                suite.assertEqual(reader.getState().scrollLevel, 3, 'Scroll level should be 3');
                
                reader.destroy();
                document.body.removeChild(testContainer);
                await waitForPending();
            });

            // ========================================
            // BIONIC READING TESTS
            // ========================================

            suite.test('Bionic mode transforms text', async () => {
                const testContainer = document.createElement('div');
                document.body.appendChild(testContainer);
                const reader = new EBookReader(testContainer);
                
                reader.loadContent('<p>reading</p>');
                reader.setBionic(true);
                
                await waitForPending();
                
                const bionicSpans = reader.el.content.querySelectorAll('.bionic');
                suite.assert(bionicSpans.length > 0, 'Should have bionic spans');
                
                reader.destroy();
                document.body.removeChild(testContainer);
                await waitForPending();
            });

            suite.test('Bionic mode toggles correctly', async () => {
                const testContainer = document.createElement('div');
                document.body.appendChild(testContainer);
                const reader = new EBookReader(testContainer);
                
                reader.loadContent('<p>test</p>');
                
                reader.setBionic(true);
                suite.assertEqual(reader.getState().bionic, true, 'Should be enabled');
                
                reader.setBionic(false);
                suite.assertEqual(reader.getState().bionic, false, 'Should be disabled');
                
                reader.destroy();
                document.body.removeChild(testContainer);
                await waitForPending();
            });

            suite.test('Flow mode with bionic works', async () => {
                const testContainer = document.createElement('div');
                document.body.appendChild(testContainer);
                const reader = new EBookReader(testContainer);
                
                reader.loadContent('<p>reading writing</p>');
                reader.setBionic(true);
                reader.setMode('flow');
                
                await waitForPending();
                
                const wordSpans = reader.el.content.querySelectorAll('.flow-word');
                const bionicSpans = reader.el.content.querySelectorAll('.bionic');
                
                suite.assert(wordSpans.length > 0, 'Should have word spans');
                suite.assert(bionicSpans.length > 0, 'Should have bionic spans');
                
                reader.destroy();
                document.body.removeChild(testContainer);
                await waitForPending();
            });

            // ========================================
            // EVENT SYSTEM TESTS
            // ========================================

            suite.test('Event system works', async () => {
                const testContainer = document.createElement('div');
                document.body.appendChild(testContainer);
                const reader = new EBookReader(testContainer);
                
                let eventFired = false;
                let eventData = null;
                
                reader.on('onModeChange', (mode) => {
                    eventFired = true;
                    eventData = mode;
                });
                
                reader.loadContent('<p>Test</p>');
                reader.setMode('flow');
                
                suite.assert(eventFired, 'Event should fire');
                suite.assertEqual(eventData, 'flow', 'Event data should be correct');
                
                reader.destroy();
                document.body.removeChild(testContainer);
                await waitForPending();
            });

            suite.test('Event unsubscribe works', async () => {
                const testContainer = document.createElement('div');
                document.body.appendChild(testContainer);
                const reader = new EBookReader(testContainer);
                
                let callCount = 0;
                const callback = () => callCount++;
                
                reader.on('onModeChange', callback);
                reader.loadContent('<p>Test</p>');
                reader.setMode('flow');
                
                suite.assertEqual(callCount, 1, 'Should fire once');
                
                reader.off('onModeChange', callback);
                reader.setMode('normal');
                
                suite.assertEqual(callCount, 1, 'Should not fire after unsubscribe');
                
                reader.destroy();
                document.body.removeChild(testContainer);
                await waitForPending();
            });

            // ========================================
            // FLOW MODE TESTS
            // ========================================

            suite.test('Flow mode creates word spans', async () => {
                const testContainer = document.createElement('div');
                document.body.appendChild(testContainer);
                const reader = new EBookReader(testContainer);
                
                reader.loadContent('<p>The quick brown fox jumps</p>');
                reader.setMode('flow');
                
                await waitForPending();
                
                const wordSpans = reader.el.content.querySelectorAll('.flow-word');
                suite.assert(wordSpans.length >= 5, 'Should create word spans');
                
                reader.destroy();
                document.body.removeChild(testContainer);
                await waitForPending();
            });

            suite.test('Play/pause works', async () => {
                const testContainer = document.createElement('div');
                document.body.appendChild(testContainer);
                const reader = new EBookReader(testContainer);
                
                reader.loadContent('<p>Test content</p>');
                reader.setMode('flow');
                
                await waitForPending();
                
                suite.assertEqual(reader.getState().isPlaying, false, 'Should not be playing');
                
                reader.play();
                suite.assertEqual(reader.getState().isPlaying, true, 'Should be playing');
                
                reader.pause();
                suite.assertEqual(reader.getState().isPlaying, false, 'Should be paused');
                
                reader.destroy();
                document.body.removeChild(testContainer);
                await waitForPending();
            });

            // ========================================
            // WORD INDEX MANAGER TESTS
            // ========================================

            suite.test('WordIndexManager initializes', () => {
                const manager = new WordIndexManager();
                suite.assertEqual(manager.dirty, true, 'Should be dirty initially');
                
                const total = manager.getTotalWords();
                suite.assert(total >= 0, 'Should return valid count');
                suite.assertEqual(manager.dirty, false, 'Should not be dirty after rebuild');
            });

            suite.test('WordIndexManager rebuilds with words', async () => {
                const testContainer = document.createElement('div');
                testContainer.style.position = 'absolute';
                testContainer.style.left = '-9999px';
                document.body.appendChild(testContainer);
                const reader = new EBookReader(testContainer);
                
                reader.loadContent('<p>One two three four five</p>');
                reader.setMode('flow');
                
                await waitForPending();
                
                const mainReader = document.getElementById('reader-container');
                const originalDisplay = mainReader.style.display;
                mainReader.style.display = 'none';
                
                if (reader.wordIndexManager) {
                    reader.wordIndexManager.rebuild();
                    const totalWords = reader.wordIndexManager.getTotalWords();
                    suite.assert(totalWords >= 5, `Should have at least 5 words`);
                }
                
                mainReader.style.display = originalDisplay;
                
                reader.destroy();
                document.body.removeChild(testContainer);
                await waitForPending();
            });

            suite.test('WordIndexManager getWord returns data', async () => {
                const testContainer = document.createElement('div');
                testContainer.style.position = 'absolute';
                testContainer.style.left = '-9999px';
                document.body.appendChild(testContainer);
                const reader = new EBookReader(testContainer);
                
                reader.loadContent('<p>Hello world</p>');
                reader.setMode('flow');
                
                await waitForPending();
                
                const mainReader = document.getElementById('reader-container');
                const originalDisplay = mainReader.style.display;
                mainReader.style.display = 'none';
                
                if (reader.wordIndexManager) {
                    reader.wordIndexManager.rebuild();
                    const word = reader.wordIndexManager.getWord(0);
                    
                    suite.assert(word !== null, 'Should get word');
                    suite.assert('el' in word, 'Should have el property');
                    suite.assert('text' in word, 'Should have text property');
                }
                
                mainReader.style.display = originalDisplay;
                
                reader.destroy();
                document.body.removeChild(testContainer);
                await waitForPending();
            });

            // ========================================
            // STATE MANAGEMENT TESTS
            // ========================================

            suite.test('getState() returns complete state', async () => {
                const testContainer = document.createElement('div');
                document.body.appendChild(testContainer);
                const reader = new EBookReader(testContainer);
                
                const state = reader.getState();
                
                suite.assert('version' in state, 'Should have version');
                suite.assert('mode' in state, 'Should have mode');
                suite.assert('bionic' in state, 'Should have bionic');
                suite.assert('isPlaying' in state, 'Should have isPlaying');
                suite.assert('speed' in state, 'Should have speed');
                suite.assert('focusWidth' in state, 'Should have focusWidth');
                
                reader.destroy();
                document.body.removeChild(testContainer);
                await waitForPending();
            });

            suite.test('Mode switching preserves position', async () => {
                const testContainer = document.createElement('div');
                document.body.appendChild(testContainer);
                const reader = new EBookReader(testContainer);
                
                reader.loadContent('<p>One two three four five six</p>');
                reader.setMode('flow');
                
                await waitForPending();
                
                reader.state.flow.currentWordIndex = 3;
                
                reader.setMode('normal');
                await waitForPending();
                
                reader.setMode('flow');
                await waitForPending();
                
                suite.assert(reader.state.flow.currentWordIndex >= 0, 'Position should be preserved');
                
                reader.destroy();
                document.body.removeChild(testContainer);
                await waitForPending();
            });

            // ========================================
            // CLEANUP TESTS
            // ========================================

            suite.test('Destroy cleans up resources', async () => {
                const testContainer = document.createElement('div');
                document.body.appendChild(testContainer);
                const reader = new EBookReader(testContainer);
                
                reader.loadContent('<p>Test</p>');
                reader.setMode('flow');
                
                await waitForPending();
                
                reader.play();
                reader.destroy();
                
                await waitForPending();
                
                suite.assertEqual(testContainer.innerHTML, '', 'Container should be empty');
                suite.assertEqual(reader.wordIndexManager, null, 'Manager should be null');
                
                document.body.removeChild(testContainer);
            });

            // Display results
            const results = await suite.run();
            const resultsDiv = document.getElementById('test-results');
            
            let html = '<div class="test-header"><span>Test Results</span><span class="test-close" onclick="document.getElementById(\'test-results\').classList.remove(\'visible\')">âœ•</span></div>';
            
            // Group results by category
            const categories = {
                'Initialization': results.slice(0, 4),
                'Content Loading': results.slice(4, 6),
                'Public API': results.slice(6, 11),
                'Bionic Reading': results.slice(11, 14),
                'Event System': results.slice(14, 16),
                'Flow Mode': results.slice(16, 17),
                'Word Index': results.slice(17, 20),
                'State Management': results.slice(20, 22),
                'Cleanup': results.slice(22, 23)
            };
            
            for (const [category, tests] of Object.entries(categories)) {
                if (tests.length === 0) continue;
                
                const allPassed = tests.every(t => t.passed);
                const categoryIcon = allPassed ? 'âœ“' : 'âœ—';
                const categoryClass = allPassed ? 'test-pass' : 'test-fail';
                
                html += `<div style="font-weight:600;margin-top:12px;margin-bottom:6px;font-size:12px;color:#333;">
                    <span class="${categoryClass}">${categoryIcon}</span> ${category}
                </div>`;
                
                tests.forEach(result => {
                    const icon = result.passed ? 'âœ“' : 'âœ—';
                    const className = result.passed ? 'test-pass' : 'test-fail';
                    const testName = result.name.replace(/^(Library|Constructor|Content|setMode|setBionic|setSpeed|setFocusWidth|setScrollLevel|Bionic|Event|Flow|Play|WordIndexManager|getState|Mode|Destroy)\s+/i, '');
                    html += `<div class="test-item ${className}" style="padding-left:12px;font-size:12px;">${icon} ${testName}</div>`;
                    if (!result.passed) {
                        html += `<div style="font-size:11px;color:#666;margin-left:32px;margin-bottom:4px;">${result.error}</div>`;
                    }
                });
            }
            
            html += `<div class="test-summary">
                Passed: <span class="test-pass">${suite.passed}</span> | 
                Failed: <span class="test-fail">${suite.failed}</span> | 
                Total: ${suite.tests.length}
            </div>`;
            
            resultsDiv.innerHTML = html;
            resultsDiv.classList.add('visible');

            return { passed: suite.passed, failed: suite.failed, total: suite.tests.length };
        }

        // Expose test runner
        window.EBookReaderTests = {
            run: runTests,
            
            watch: async function() {
                console.clear();
                console.log('ðŸ” Running tests...\n');
                
                const start = performance.now();
                const result = await runTests();
                const duration = (performance.now() - start).toFixed(0);
                
                console.log(`\nâ±ï¸  Completed in ${duration}ms`);
                
                if (result.failed === 0) {
                    console.log(`âœ… All ${result.total} tests passed!`);
                } else {
                    console.log(`âŒ ${result.failed} test(s) failed`);
                }
                
                return result;
            }
        };

        // ============================================================================
        // EXAMPLE: EXTERNAL UI CONTROLLER
        // ============================================================================

        const sampleContent = `
            <h1>Chapter One: The Beginning</h1>
            <p>In the heart of Silicon Valley, where innovation breathed life into dreams and ambition fueled the relentless pursuit of progress, there existed a small startup that dared to challenge the giants. The morning sun cast long shadows through the floor-to-ceiling windows of their modest office, illuminating screens filled with code and whiteboards covered in sketches of impossible ideas.</p>
            <p>Sarah had always believed that the best products were born from frustration. It was a Tuesday afternoon when she threw her e-reader across the roomâ€”not hard enough to break it, but with enough force to express her complete dissatisfaction with the experience. "Why," she asked her co-founder Marcus, "does every reading app feel like it was designed in 2010?"</p>
            <p>Marcus looked up from his laptop, his fingers still hovering over the keyboard. He'd been wrestling with the same question for months. The reading experience hadn't evolved. Sure, screens got sharper and devices got thinner, but the fundamental interaction between human and text remained stubbornly unchanged.</p>
        `;

        // Initialize core library
        window.reader = new EBookReader('#reader-container');
        reader.loadContent(sampleContent);

        // Connect external UI to library
        const btnBionic = document.getElementById('btn-bionic');
        const btnFlow = document.getElementById('btn-flow');
        const btnPlay = document.getElementById('btn-play');
        const flowControls = document.getElementById('flow-controls');
        const speedSlider = document.getElementById('speed-slider');
        const speedLabel = document.getElementById('speed-label');
        const focusSlider = document.getElementById('focus-slider');
        const focusLabel = document.getElementById('focus-label');
        const scrollSlider = document.getElementById('scroll-slider');
        const scrollLabel = document.getElementById('scroll-label');

        // Wire up buttons to library API
        btnBionic.addEventListener('click', () => {
            reader.setBionic(!reader.getState().bionic);
            btnBionic.classList.toggle('active');
        });

        btnFlow.addEventListener('click', () => {
            const currentMode = reader.getState().mode;
            const newMode = currentMode === 'flow' ? 'normal' : 'flow';
            reader.setMode(newMode);
            btnFlow.classList.toggle('active', newMode === 'flow');
            flowControls.style.display = newMode === 'flow' ? 'flex' : 'none';
        });

        btnPlay.addEventListener('click', () => {
            reader.togglePlay();
        });

        speedSlider.addEventListener('input', (e) => {
            reader.setSpeed(+e.target.value);
            speedLabel.textContent = e.target.value + ' wpm';
        });

        focusSlider.addEventListener('input', (e) => {
            reader.setFocusWidth(+e.target.value);
            focusLabel.textContent = e.target.value;
        });

        scrollSlider.addEventListener('input', (e) => {
            const level = +e.target.value;
            reader.setScrollLevel(level);
            const labels = ['Top', 'Upper', 'Middle', 'Lower', 'Bottom'];
            scrollLabel.textContent = labels[level - 1];
        });

        // Listen to library events
        reader.on('onPlayChange', (isPlaying) => {
            btnPlay.textContent = isPlaying ? 'â¸ Pause' : 'â–¶ Play';
            console.log('Play state changed:', isPlaying);
        });

        reader.on('onModeChange', (mode) => {
            console.log('Mode changed:', mode);
        });

        reader.on('onBionicChange', (enabled) => {
            console.log('Bionic changed:', enabled);
        });

        // Log initialization
        console.log('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—');
        console.log('â•‘   EBookReader v' + EBookReader.VERSION + ' (Separated)     â•‘');
        console.log('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
        console.log('');
        console.log('ðŸ—ï¸  ARCHITECTURE:');
        console.log('   âœ“ Core library: Provides reading functionality');
        console.log('   âœ“ External UI: Toolbar built separately');
        console.log('   âœ“ Clean API: Library exposes methods, not UI');
        console.log('');
        console.log('ðŸ“š PUBLIC API:');
        console.log('   reader.setMode("flow" | "normal")');
        console.log('   reader.setBionic(true | false)');
        console.log('   reader.setSpeed(wpm)');
        console.log('   reader.setFocusWidth(width)');
        console.log('   reader.play() / pause() / togglePlay()');
        console.log('   reader.getState()');
        console.log('   reader.on(event, callback)');
        console.log('   reader.off(event, callback)');
        console.log('');
        console.log('ðŸŽ¯ WHAT LIBRARY INCLUDES:');
        console.log('   âœ“ Reading area with text');
        console.log('   âœ“ Draggable margins (hover edges to resize)');
        console.log('   âœ“ Focus highlight indicator');
        console.log('   âœ“ Touch gestures (pinch-zoom)');
        console.log('');
        console.log('âŒ WHAT LIBRARY EXCLUDES:');
        console.log('   âœ— Toolbar (build your own!)');
        console.log('   âœ— Buttons (use API instead)');
        console.log('   âœ— Control sliders (optional)');
        console.log('');
        console.log('ðŸ§ª TESTS (23 tests covering all features):');
        console.log('   await EBookReaderTests.run()    â†’ Full panel');
        console.log('   await EBookReaderTests.watch()  â†’ Quick console');
        console.log('');
        console.log('Current state:', reader.getState());
    </script>
</body>
</html>