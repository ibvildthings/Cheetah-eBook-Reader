<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EBookReader v2.0.0 - Ultra Smooth</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        
        /* Test Results Panel */
        #test-results {
            position: fixed;
            top: 10px;
            right: 10px;
            background: white;
            border: 2px solid #e5e7eb;
            border-radius: 8px;
            padding: 15px;
            max-width: 350px;
            max-height: 500px;
            overflow-y: auto;
            z-index: 1000;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
            display: none;
        }

        #test-results.visible {
            display: block;
        }

        .test-header {
            font-weight: 600;
            margin-bottom: 10px;
            padding-bottom: 10px;
            border-bottom: 2px solid #e5e7eb;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .test-close {
            cursor: pointer;
            font-size: 18px;
            color: #666;
            padding: 0 5px;
        }

        .test-close:hover {
            color: #000;
        }

        .test-item {
            padding: 5px 0;
            font-size: 13px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .test-pass { color: #10b981; }
        .test-fail { color: #ef4444; }
        .test-summary {
            margin-top: 10px;
            padding-top: 10px;
            border-top: 2px solid #e5e7eb;
            font-weight: 600;
        }
        
        /* Example UI Styles (NOT part of library) */
        .demo-toolbar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            background: #fff;
            border-bottom: 1px solid #e5e7eb;
            padding: 15px 20px;
            z-index: 300;
            box-shadow: 0 2px 8px rgba(0,0,0,.05);
            display: flex;
            gap: 20px;
            align-items: center;
            flex-wrap: wrap;
        }

        .demo-btn {
            padding: 8px 16px;
            border: 2px solid #e5e7eb;
            background: #fff;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: all .2s;
        }

        .demo-btn:hover {
            border-color: #3b82f6;
            background: #f0f9ff;
        }

        .demo-btn.active {
            border-color: #3b82f6;
            background: #3b82f6;
            color: #fff;
        }

        .demo-control {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .demo-label {
            font-size: 12px;
            color: #666;
            font-weight: 600;
        }

        #reader-container {
            width: 100vw;
            height: 100vh;
            padding-top: 80px;
        }
    </style>
</head>
<body>
    <!-- Test Results Panel -->
    <div id="test-results"></div>
    
    <!-- External UI (NOT part of library) -->
    <div class="demo-toolbar">
        <button class="demo-btn" id="btn-bionic">Bionic Reading</button>
        <button class="demo-btn" id="btn-flow">Flow Mode</button>
        
        <div class="demo-control" id="flow-controls" style="display:none;">
            <span class="demo-label">Speed:</span>
            <input type="range" id="speed-slider" min="100" max="600" value="300" step="10">
            <span id="speed-label" class="demo-label">300 wpm</span>
            
            <span class="demo-label">Focus:</span>
            <input type="range" id="focus-slider" min="1" max="5" value="2" step="0.5">
            <span id="focus-label" class="demo-label">2</span>
            
            <span class="demo-label">Position:</span>
            <input type="range" id="scroll-slider" min="1" max="5" value="1" step="1">
            <span id="scroll-label" class="demo-label">Top</span>
            
            <button class="demo-btn" id="btn-play">â–¶ Play</button>
        </div>
    </div>

    <!-- Library only needs this container -->
    <div id="reader-container"></div>

    <script>
        /**
         * EBookReader Core Library v2.0.0
         * Pure reading functionality - NO UI components
         * 
         * @license MIT
         * @version 2.0.0
         */

        // ============================================================================
        // ERROR CLASSES
        // ============================================================================

        class EBookReaderError extends Error {
            constructor(message) {
                super(message);
                this.name = 'EBookReaderError';
            }
        }

        class ConfigurationError extends EBookReaderError {
            constructor(message) {
                super(message);
                this.name = 'ConfigurationError';
            }
        }

        class ContentError extends EBookReaderError {
            constructor(message) {
                super(message);
                this.name = 'ContentError';
            }
        }

        class StateError extends EBookReaderError {
            constructor(message) {
                super(message);
                this.name = 'StateError';
            }
        }

        // ============================================================================
        // WORD INDEX MANAGER
        // ============================================================================

        class WordIndexManager {
            constructor() {
                this.words = [];
                this.dirty = true;
            }

            rebuild() {
                try {
                    this.words = [];
                    const wordElements = document.querySelectorAll('.flow-word');
                    
                    if (!wordElements.length) {
                        this.dirty = false;
                        return;
                    }

                    let prevTop = -1;
                    wordElements.forEach((el, idx) => {
                        const rect = el.getBoundingClientRect();
                        const isNewline = prevTop !== -1 && rect.top > prevTop + 5;
                        
                        this.words.push({
                            el,
                            rect: {
                                left: rect.left,
                                right: rect.right,
                                top: rect.top,
                                bottom: rect.bottom,
                                width: rect.width,
                                height: rect.height
                            },
                            isNewline,
                            text: el.textContent,
                            index: idx
                        });
                        
                        prevTop = rect.top;
                    });
                    
                    this.dirty = false;
                } catch (error) {
                    throw new StateError(`Failed to rebuild word index: ${error.message}`);
                }
            }

            getWord(index) {
                if (typeof index !== 'number' || isNaN(index)) {
                    throw new TypeError('Word index must be a valid number');
                }
                
                if (this.dirty) this.rebuild();
                const idx = Math.floor(index);
                return this.words[idx] || null;
            }

            getActiveRange(centerIndex, focusWidth) {
                if (typeof centerIndex !== 'number' || isNaN(centerIndex)) {
                    throw new TypeError('Center index must be a valid number');
                }
                if (typeof focusWidth !== 'number' || focusWidth <= 0) {
                    throw new TypeError('Focus width must be a positive number');
                }
                
                if (this.dirty) this.rebuild();
                
                const centerIdx = Math.floor(centerIndex);
                const centerWord = this.words[centerIdx];
                
                if (!centerWord) return { start: 0, end: 0 };

                const centerTop = centerWord.rect.top;
                const halfWidth = focusWidth / 2;
                
                let start = Math.max(0, Math.round(centerIndex - halfWidth));
                let end = Math.min(this.words.length - 1, Math.round(centerIndex + halfWidth));

                while (start < centerIdx && this.words[start] && 
                       Math.abs(this.words[start].rect.top - centerTop) > 5) {
                    start++;
                }
                
                while (end > centerIdx && this.words[end] && 
                       Math.abs(this.words[end].rect.top - centerTop) > 5) {
                    end--;
                }

                return { start, end };
            }

            getTotalWords() {
                if (this.dirty) this.rebuild();
                return this.words.length;
            }

            invalidate() {
                this.dirty = true;
            }
        }

        // ============================================================================
        // CORE EBOOK READER (NO UI)
        // ============================================================================

        class EBookReader {
            static VERSION = '2.0.0';

            constructor(containerSelector, options = {}) {
                try {
                    this._validateConstructorArgs(containerSelector, options);
                    
                    this.config = {
                        fontSize: { min: 12, default: 18, max: 48 },
                        margin: { min: 10, default: 60, max: 400 },
                        speed: { min: 100, default: 300, max: 600 },
                        lineHeight: 1.6,
                        newlinePause: 1.5,
                        scroll: {
                            timeout: 1500,
                            gap: 0.1,
                            // Comfort zone approach - only scroll when word drifts outside zone
                            comfortZoneTop: 0.15,      // 15% from top
                            comfortZoneBottom: 0.70    // 70% from top (30% from bottom)
                        }
                    };

                    this.state = {
                        fontSize: this._validateOption(options.fontSize, this.config.fontSize, 'fontSize'),
                        lineHeight: this.config.lineHeight,
                        marginL: this._validateOption(options.margin, this.config.margin, 'margin'),
                        marginR: this._validateOption(options.margin, this.config.margin, 'margin'),
                        marginTB: 40,
                        mode: 'normal',
                        bionic: false,
                        content: '',
                        flow: {
                            playing: false,
                            speed: this.config.speed.default,
                            currentWordIndex: 0,
                            startTime: 0,
                            rafId: null,
                            userScroll: false,
                            fingers: 2,
                            scrollLevel: 1,
                            pauseUntil: 0,
                            lastPausedWord: -1
                        },
                        gesture: {
                            touches: [],
                            initDist: 0,
                            initSize: 0,
                            dragging: false,
                            side: null,
                            initMargin: 0,
                            initX: 0
                        },
                        saved: null
                    };

                    // Event callbacks (external UI can subscribe)
                    this.callbacks = {
                        onModeChange: [],
                        onBionicChange: [],
                        onPlayChange: [],
                        onSpeedChange: [],
                        onStateChange: []
                    };

                    this.container = typeof containerSelector === 'string' 
                        ? document.querySelector(containerSelector) 
                        : containerSelector;
                    
                    if (!this.container) {
                        throw new ConfigurationError(
                            `Container element not found: "${containerSelector}"`
                        );
                    }

                    this.wordIndexManager = new WordIndexManager();
                    this._destroyed = false;
                    
                    // Bind event handlers so we can remove them later
                    this._resizeHandler = () => this.updateStyles();
                    this._scrollHandler = () => this._handleScroll();
                    
                    this._injectStyles();
                    this._buildDOM();
                    this._attachEventListeners();
                    
                    requestAnimationFrame(() => {
                        this.updateStyles();
                        // Initialize drag zone sizes
                        if (this.el.dragZoneL && this.el.dragZoneR && this.el.content) {
                            const contentHeight = this.el.content.scrollHeight;
                            const leftWidth = Math.max(60, this.state.marginL);
                            const rightWidth = Math.max(60, this.state.marginR);
                            
                            this.el.dragZoneL.style.width = leftWidth + 'px';
                            this.el.dragZoneL.style.height = contentHeight + 'px';
                            
                            this.el.dragZoneR.style.width = rightWidth + 'px';
                            this.el.dragZoneR.style.height = contentHeight + 'px';
                        }
                    });
                } catch (error) {
                    if (error instanceof EBookReaderError) {
                        throw error;
                    }
                    throw new ConfigurationError(`Failed to initialize: ${error.message}`);
                }
            }

            // ========================================
            // PUBLIC API (for external UI)
            // ========================================

            loadContent(html) {
                if (typeof html !== 'string') {
                    throw new ContentError(`Content must be a string`);
                }
                if (html.trim().length === 0) {
                    throw new ContentError('Content cannot be empty');
                }

                this.state.content = html;
                this._render();
            }

            setMode(mode) {
                if (mode !== 'normal' && mode !== 'flow') {
                    throw new Error('Mode must be "normal" or "flow"');
                }
                this._setMode(mode, true);
                this._emit('onModeChange', mode);
            }

            setBionic(enabled) {
                if (this.state.bionic !== enabled) {
                    this._toggleBionic();
                    this._emit('onBionicChange', enabled);
                }
            }

            setSpeed(wpm) {
                if (typeof wpm !== 'number' || wpm < this.config.speed.min || wpm > this.config.speed.max) {
                    throw new Error(`Speed must be between ${this.config.speed.min} and ${this.config.speed.max}`);
                }
                this.state.flow.speed = wpm;
                this._emit('onSpeedChange', wpm);
            }

            setFocusWidth(width) {
                if (typeof width !== 'number' || width < 1 || width > 5) {
                    throw new Error('Focus width must be between 1 and 5');
                }
                this.state.flow.fingers = width;
                if (this.state.mode === 'flow' && !this._destroyed && this.wordIndexManager) {
                    this._updateWordStates(this.state.flow.currentWordIndex);
                }
            }

            setScrollLevel(level) {
                if (typeof level !== 'number' || level < 1 || level > 5) {
                    throw new Error('Scroll level must be between 1 and 5');
                }
                this.state.flow.scrollLevel = level;
            }

            play() {
                if (!this.state.flow.playing && this.state.mode === 'flow') {
                    this._togglePlay();
                }
            }

            pause() {
                if (this.state.flow.playing) {
                    this._togglePlay();
                }
            }

            togglePlay() {
                if (this.state.mode === 'flow') {
                    this._togglePlay();
                }
            }

            jumpToWord(index) {
                if (this.state.mode === 'flow') {
                    this._jumpToWord(index);
                }
            }

            getState() {
                return {
                    version: EBookReader.VERSION,
                    mode: this.state.mode,
                    bionic: this.state.bionic,
                    fontSize: this.state.fontSize,
                    isPlaying: this.state.flow.playing,
                    currentWordIndex: this.state.flow.currentWordIndex,
                    totalWords: this.wordIndexManager ? this.wordIndexManager.getTotalWords() : 0,
                    speed: this.state.flow.speed,
                    focusWidth: this.state.flow.fingers,
                    scrollLevel: this.state.flow.scrollLevel
                };
            }

            on(event, callback) {
                if (this.callbacks[event]) {
                    this.callbacks[event].push(callback);
                }
            }

            off(event, callback) {
                if (this.callbacks[event]) {
                    this.callbacks[event] = this.callbacks[event].filter(cb => cb !== callback);
                }
            }

            destroy() {
                try {
                    // Stop any playing animation
                    if (this.state.flow.playing) {
                        cancelAnimationFrame(this.state.flow.rafId);
                    }
                    
                    // Remove event listeners to prevent errors after destroy
                    window.removeEventListener('resize', this._resizeHandler);
                    
                    if (this.el && this.el.reader) {
                        this.el.reader.removeEventListener('scroll', this._scrollHandler);
                    }
                    
                    // Clear container
                    if (this.container) {
                        this.container.innerHTML = '';
                    }
                    
                    // Mark as destroyed
                    this._destroyed = true;
                    this.wordIndexManager = null;
                } catch (error) {
                    throw new StateError(`Failed to destroy reader: ${error.message}`);
                }
            }

            // ========================================
            // PRIVATE METHODS
            // ========================================

            _emit(event, data) {
                if (this.callbacks[event]) {
                    this.callbacks[event].forEach(cb => cb(data));
                }
            }

            _validateConstructorArgs(containerSelector, options) {
                if (!containerSelector) {
                    throw new ConfigurationError('Container selector is required');
                }
                if (options && typeof options !== 'object') {
                    throw new ConfigurationError('Options must be an object');
                }
            }

            _validateOption(value, config, name) {
                if (value === undefined) return config.default;
                if (typeof value !== 'number' || isNaN(value)) {
                    throw new ConfigurationError(`${name} must be a valid number`);
                }
                if (value < config.min || value > config.max) {
                    console.warn(`${name} clamped to [${config.min}, ${config.max}]`);
                    return Math.max(config.min, Math.min(config.max, value));
                }
                return value;
            }

            _injectStyles() {
                if (document.getElementById('ebook-reader-styles')) return;

                const style = document.createElement('style');
                style.id = 'ebook-reader-styles';
                style.textContent = `
                    .ebook-reader-root {
                        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
                        background: #f5f5f5;
                        overflow: hidden;
                        touch-action: none;
                        width: 100%;
                        height: 100%;
                        display: flex;
                        justify-content: center;
                        align-items: center;
                    }
                    .ebook-reader-area {
                        position: relative;
                        background: #fff;
                        box-shadow: 0 4px 20px rgba(0,0,0,.1);
                        overflow-y: auto;
                        transition: all .1s ease-out;
                        max-height: 85vh;
                    }
                    .ebook-drag-zone {
                        position: absolute;
                        top: 0;
                        height: 100%;
                        cursor: ew-resize;
                        z-index: 100;
                        transition: background .2s, border-color .2s;
                        border: 1px dashed transparent;
                        pointer-events: auto;
                    }
                    .ebook-drag-zone-left {
                        left: 0;
                    }
                    .ebook-drag-zone-right {
                        right: 0;
                    }
                    .ebook-drag-zone:hover {
                        background: rgba(59, 130, 246, 0.08);
                        border-color: rgba(59, 130, 246, 0.2);
                    }
                    .ebook-drag-zone.active {
                        background: rgba(59, 130, 246, 0.15);
                        border-color: rgba(59, 130, 246, 0.4);
                    }
                    .ebook-text-content {
                        transition: padding .1s ease-out, opacity .2s ease-in-out;
                        position: relative;
                        min-height: 100%;
                    }
                    .ebook-text-content.transitioning { opacity: .4; }
                    .bionic { font-weight: 700; }
                    .flow-word {
                        font-weight: 400;
                        cursor: pointer;
                        display: inline;
                        position: relative;
                    }
                    .flow-word:hover { opacity: .7; }
                    .flow-word.active {
                        opacity: 1;
                        color: #1a1a1a;
                    }
                    .flow-word.inactive { opacity: .2; }
                    .ebook-focus-indicator {
                        position: absolute;
                        top: 0;
                        left: 0;
                        pointer-events: none;
                        z-index: 50;
                        background: rgba(59,130,246,.08);
                        display: none;
                        border-radius: 3px;
                    }
                    .ebook-focus-indicator.visible { display: block; }
                `;
                document.head.appendChild(style);
            }

            _buildDOM() {
                this.container.innerHTML = '';
                this.container.className = 'ebook-reader-root';

                const html = `
                    <div class="ebook-reader-area">
                        <div class="ebook-drag-zone ebook-drag-zone-left" style="width: 60px;"></div>
                        <div class="ebook-drag-zone ebook-drag-zone-right" style="width: 60px;"></div>
                        <div class="ebook-focus-indicator"></div>
                        <div class="ebook-text-content"></div>
                    </div>
                `;

                this.container.innerHTML = html;

                this.el = {
                    reader: this.container.querySelector('.ebook-reader-area'),
                    content: this.container.querySelector('.ebook-text-content'),
                    dragZoneL: this.container.querySelector('.ebook-drag-zone-left'),
                    dragZoneR: this.container.querySelector('.ebook-drag-zone-right'),
                    focus: this.container.querySelector('.ebook-focus-indicator')
                };
            }

            _attachEventListeners() {
                ['mousedown', 'touchstart'].forEach(evt => {
                    this.el.dragZoneL.addEventListener(evt, e => this._startMarginDrag(e, 'left'));
                    this.el.dragZoneR.addEventListener(evt, e => this._startMarginDrag(e, 'right'));
                });

                ['mousemove', 'touchmove'].forEach(evt => {
                    document.addEventListener(evt, e => this._handleMarginDrag(e));
                });

                ['mouseup', 'touchend'].forEach(evt => {
                    document.addEventListener(evt, () => this._stopMarginDrag());
                });

                this.el.reader.addEventListener('touchstart', e => this._handleTouchStart(e));
                this.el.reader.addEventListener('touchmove', e => this._handleTouchMove(e));
                this.el.reader.addEventListener('wheel', e => this._handleWheel(e));
                this.el.reader.addEventListener('scroll', this._scrollHandler);

                window.addEventListener('resize', this._resizeHandler);
            }

            updateStyles() {
                if (this._destroyed || !this.el || !this.el.content) return;
                
                this.el.content.style.cssText = `
                    font-size: ${this.state.fontSize}px;
                    line-height: ${this.state.lineHeight};
                    padding: ${this.state.marginTB}px ${this.state.marginR}px ${this.state.marginTB}px ${this.state.marginL}px;
                `;

                // Update drag zone widths and heights to match content
                const leftWidth = Math.max(60, this.state.marginL);
                const rightWidth = Math.max(60, this.state.marginR);
                
                // Get full content height including scrollable area
                const contentHeight = this.el.content.scrollHeight;
                
                this.el.dragZoneL.style.width = leftWidth + 'px';
                this.el.dragZoneL.style.height = contentHeight + 'px';
                
                this.el.dragZoneR.style.width = rightWidth + 'px';
                this.el.dragZoneR.style.height = contentHeight + 'px';

                if (this.state.mode === 'flow' && this.wordIndexManager) {
                    this.wordIndexManager.invalidate();
                    requestAnimationFrame(() => {
                        if (!this._destroyed && this.wordIndexManager) {
                            this._updateWordStates(this.state.flow.currentWordIndex);
                        }
                    });
                }
            }

            _render() {
                if (this._destroyed || !this.el || !this.el.content) return;
                
                this.el.content.classList.add('transitioning');
                
                let html = this.state.content;
                if (this.state.mode === 'flow') {
                    html = this._makeFlow(html, this.state.bionic);
                    if (!this.state.saved) {
                        this.state.flow.currentWordIndex = 0;
                    }
                } else if (this.state.bionic) {
                    html = this._makeBionic(html);
                }

                this.el.content.innerHTML = html;
                
                if (this.wordIndexManager) {
                    this.wordIndexManager.invalidate();
                }

                setTimeout(() => {
                    if (!this._destroyed && this.el && this.el.content) {
                        this.el.content.classList.remove('transitioning');
                        
                        // Update drag zone heights after content renders
                        const contentHeight = this.el.content.scrollHeight;
                        if (this.el.dragZoneL && this.el.dragZoneR) {
                            this.el.dragZoneL.style.height = contentHeight + 'px';
                            this.el.dragZoneR.style.height = contentHeight + 'px';
                        }
                    }
                }, 200);

                if (this.state.mode === 'flow') {
                    setTimeout(() => {
                        if (this._destroyed || !this.el || !this.el.content || !this.wordIndexManager) return;
                        
                        this.el.content.querySelectorAll('.flow-word').forEach((w, idx) => {
                            w.addEventListener('click', () => {
                                if (this.state.mode === 'flow' && !this._destroyed) this._jumpToWord(idx);
                            });
                        });
                        
                        this.wordIndexManager.rebuild();
                    }, 50);
                }
            }

            _bionicWord(w) {
                if (w.length <= 2) return w;
                const n = Math.ceil(w.length / 2);
                return `<span class="bionic">${w.slice(0, n)}</span>${w.slice(n)}`;
            }

            _makeBionic(text) {
                return text.replace(/\b(\w+)\b/g, this._bionicWord.bind(this));
            }

            _makeFlow(html, useBionic) {
                const temp = document.createElement('div');
                temp.innerHTML = html;

                const wrap = text => text.replace(/(\S+)/g, word => {
                    const parts = word.match(/[^-]+-?/g) || [word];
                    
                    return parts.map(part => {
                        let content = part;
                        if (useBionic && /\w{3,}/.test(part)) {
                            const match = part.match(/\w+/);
                            if (match) {
                                content = part.replace(match[0], this._bionicWord(match[0]));
                            }
                        }
                        return `<span class="flow-word inactive">${content}</span>`;
                    }).join('');
                });

                const process = node => {
                    if (node.nodeType === 3) {
                        const t = document.createElement('span');
                        t.innerHTML = wrap(node.textContent);
                        node.replaceWith(...t.childNodes);
                    } else if (node.nodeType === 1) {
                        [...node.childNodes].forEach(process);
                    }
                };

                [...temp.childNodes].forEach(process);
                return temp.innerHTML;
            }

            _updateWordStates(centerIndex) {
                if (this._destroyed || !this.wordIndexManager || !this.el || !this.el.content) return;
                
                this.el.content.querySelectorAll('.flow-word').forEach(w => {
                    w.className = 'flow-word inactive';
                });

                const focusWidth = this.state.flow.fingers;
                const range = this.wordIndexManager.getActiveRange(centerIndex, focusWidth);
                
                const activeElements = [];
                for (let i = range.start; i <= range.end; i++) {
                    const word = this.wordIndexManager.getWord(i);
                    if (word && word.el) {
                        word.el.classList.remove('inactive');
                        word.el.classList.add('active');
                        activeElements.push(word.el);
                    }
                }

                if (this.state.mode !== 'flow' || activeElements.length === 0) {
                    this.el.focus.classList.remove('visible');
                    return;
                }

                const activeRects = activeElements.map(el => el.getBoundingClientRect());
                const byLine = {};
                activeRects.forEach(r => {
                    const k = Math.round(r.top);
                    (byLine[k] = byLine[k] || []).push(r);
                });

                const primary = Object.values(byLine).sort((a, b) => b.length - a.length)[0];
                if (!primary) {
                    this.el.focus.classList.remove('visible');
                    return;
                }

                const minL = Math.min(...primary.map(r => r.left));
                const maxR = Math.max(...primary.map(r => r.right));
                const minT = Math.min(...primary.map(r => r.top));
                const maxB = Math.max(...primary.map(r => r.bottom));

                const rr = this.el.reader.getBoundingClientRect();
                this.el.focus.style.cssText = `
                    left: ${minL - rr.left}px;
                    width: ${maxR - minL}px;
                    top: ${minT - rr.top + this.el.reader.scrollTop}px;
                    height: ${maxB - minT}px;
                `;
                this.el.focus.classList.add('visible');
            }

            _scrollToWordIfNeeded(wordIndex) {
                if (this._destroyed || !this.wordIndexManager || this.state.flow.userScroll) return;
                if (!this.el || !this.el.reader) return;

                // Get current word position with interpolation
                const currentIdx = Math.floor(wordIndex);
                const nextIdx = currentIdx + 1;
                const fraction = wordIndex - currentIdx;

                const currentWord = this.wordIndexManager.getWord(currentIdx);
                const nextWord = this.wordIndexManager.getWord(nextIdx);
                
                if (!currentWord) return;

                // Calculate interpolated word position
                let wordTop = currentWord.el.getBoundingClientRect().top;
                if (nextWord && fraction > 0) {
                    const nextTop = nextWord.el.getBoundingClientRect().top;
                    wordTop = wordTop + (nextTop - wordTop) * fraction;
                }

                const readerRect = this.el.reader.getBoundingClientRect();
                const viewportHeight = readerRect.height;
                
                // Define comfort zone boundaries
                const comfortZoneTop = readerRect.top + (viewportHeight * this.config.scroll.comfortZoneTop);
                const comfortZoneBottom = readerRect.top + (viewportHeight * this.config.scroll.comfortZoneBottom);
                
                // Check if word is outside comfort zone
                if (wordTop < comfortZoneTop || wordTop > comfortZoneBottom) {
                    // Calculate target position based on scroll level
                    const targetRatio = this.config.scroll.gap + (this.state.flow.scrollLevel - 1) * 0.2;
                    const targetY = readerRect.top + (viewportHeight * targetRatio);
                    
                    // Calculate how much to scroll
                    const scrollAdjustment = wordTop - targetY;
                    const targetScroll = this.el.reader.scrollTop + scrollAdjustment;
                    
                    // Let browser handle smooth scrolling
                    this.el.reader.scrollTo({
                        top: targetScroll,
                        behavior: 'smooth'
                    });
                }
                // If inside comfort zone, do nothing - this is the key to smoothness!
            }

            _animate() {
                const frame = (t) => {
                    if (!this.state.flow.playing || this._destroyed || !this.wordIndexManager) return;

                    if (this.state.flow.pauseUntil > 0) {
                        if (t < this.state.flow.pauseUntil) {
                            this.state.flow.rafId = requestAnimationFrame(frame);
                            return;
                        }
                        this.state.flow.startTime = t - (this.state.flow.currentWordIndex / (this.state.flow.speed / 60)) * 1000;
                        this.state.flow.pauseUntil = 0;
                    }

                    const elapsed = t - this.state.flow.startTime;
                    const wordsPerSecond = this.state.flow.speed / 60;
                    const wordIndex = (elapsed / 1000) * wordsPerSecond;

                    this.state.flow.currentWordIndex = wordIndex;

                    const totalWords = this.wordIndexManager.getTotalWords();
                    if (wordIndex >= totalWords) {
                        this.state.flow.currentWordIndex = 0;
                        this.state.flow.startTime = t;
                        this.state.flow.pauseUntil = 0;
                        this.state.flow.lastPausedWord = -1;
                    }

                    const currentWordIdx = Math.floor(wordIndex);
                    const currentWord = this.wordIndexManager.getWord(currentWordIdx);

                    // Check if we need to scroll (only when word exits comfort zone)
                    this._scrollToWordIfNeeded(wordIndex);

                    this._updateWordStates(wordIndex);

                    if (currentWord && currentWord.isNewline && 
                        this.state.flow.pauseUntil === 0 && 
                        this.state.flow.lastPausedWord !== currentWordIdx) {
                        const pauseDuration = (60000 / this.state.flow.speed) * this.config.newlinePause;
                        this.state.flow.pauseUntil = t + pauseDuration;
                        this.state.flow.lastPausedWord = currentWordIdx;
                    }

                    this.state.flow.rafId = requestAnimationFrame(frame);
                };

                this.state.flow.rafId = requestAnimationFrame(frame);
            }

            _togglePlay() {
                if (this._destroyed || !this.wordIndexManager) return;
                
                if (this.state.flow.playing) {
                    cancelAnimationFrame(this.state.flow.rafId);
                    this.state.flow.playing = false;
                } else {
                    this.wordIndexManager.rebuild();
                    const totalWords = this.wordIndexManager.getTotalWords();
                    if (!totalWords) return;

                    this.state.flow.playing = true;
                    
                    const wordsPerSecond = this.state.flow.speed / 60;
                    this.state.flow.startTime = performance.now() - 
                        (this.state.flow.currentWordIndex / wordsPerSecond) * 1000;
                    this.state.flow.pauseUntil = 0;
                    this.state.flow.lastPausedWord = -1;
                    
                    this._animate();
                }
                this._emit('onPlayChange', this.state.flow.playing);
            }

            _jumpToWord(idx) {
                if (this._destroyed || !this.wordIndexManager) return;
                
                this.state.flow.currentWordIndex = idx;
                
                // Instant jump - calculate ideal scroll position and jump there
                const word = this.wordIndexManager.getWord(idx);
                if (word && this.el && this.el.reader) {
                    const rr = this.el.reader.getBoundingClientRect();
                    const vhh = rr.height;
                    const targetRatio = this.config.scroll.gap + (this.state.flow.scrollLevel - 1) * 0.2;
                    const idealY = rr.top + (vhh * targetRatio);
                    const wordTop = word.el.getBoundingClientRect().top;
                    const diff = wordTop - idealY;
                    
                    this.el.reader.scrollTop = this.el.reader.scrollTop + diff;
                }
                
                if (!this.state.flow.playing) {
                    this._updateWordStates(idx);
                } else {
                    const wordsPerSecond = this.state.flow.speed / 60;
                    this.state.flow.startTime = performance.now() - (idx / wordsPerSecond) * 1000;
                    this.state.flow.pauseUntil = 0;
                    this.state.flow.lastPausedWord = -1;
                    this._updateWordStates(idx);
                }
            }

            _setMode(mode, preserve = false) {
                if (this._destroyed) return;
                
                const wasPlaying = this.state.flow.playing;
                
                if (this.state.mode === 'flow' && mode !== 'flow') {
                    this.state.saved = {
                        wordIndex: this.state.flow.currentWordIndex,
                        playing: wasPlaying
                    };
                }

                this.state.mode = mode;
                
                if (this.state.flow.playing) this._togglePlay();

                this._render();

                if (mode === 'flow' && this.state.saved && preserve) {
                    setTimeout(() => {
                        if (this._destroyed || !this.wordIndexManager) return;
                        
                        this.state.flow.currentWordIndex = this.state.saved.wordIndex || 0;
                        this._updateWordStates(this.state.flow.currentWordIndex);
                        if (this.state.saved.playing) {
                            setTimeout(() => {
                                if (!this._destroyed && this.wordIndexManager) this._togglePlay();
                            }, 100);
                        }
                    }, 100);
                } else if (mode === 'flow') {
                    setTimeout(() => {
                        if (!this._destroyed && this.wordIndexManager) {
                            this._updateWordStates(this.state.flow.currentWordIndex);
                        }
                    }, 100);
                }

                if (mode !== 'flow') {
                    this.el.focus.classList.remove('visible');
                }
            }

            _toggleBionic() {
                if (this._destroyed) return;
                
                const wasPlaying = this.state.flow.playing;
                const savedIdx = this.state.flow.currentWordIndex;
                
                this.state.bionic = !this.state.bionic;
                
                if (wasPlaying) this._togglePlay();
                
                this._render();
                
                if (this.state.mode === 'flow') {
                    setTimeout(() => {
                        if (this._destroyed || !this.wordIndexManager) return;
                        
                        this.state.flow.currentWordIndex = savedIdx;
                        this._updateWordStates(savedIdx);
                        if (wasPlaying) {
                            setTimeout(() => {
                                if (!this._destroyed && this.wordIndexManager) this._togglePlay();
                            }, 100);
                        }
                    }, 100);
                }
            }

            _startMarginDrag(e, side) {
                e.preventDefault();
                this.state.gesture.dragging = true;
                this.state.gesture.side = side;
                
                const zone = side === 'left' ? this.el.dragZoneL : this.el.dragZoneR;
                zone.classList.add('active');

                const x = e.touches?.[0]?.clientX || e.clientX;
                this.state.gesture.initX = x;
                this.state.gesture.initMargin = side === 'left' ? this.state.marginL : this.state.marginR;
            }

            _handleMarginDrag(e) {
                if (!this.state.gesture.dragging) return;

                const x = e.touches?.[0]?.clientX || e.clientX;
                const delta = x - this.state.gesture.initX;
                
                let val = this.state.gesture.initMargin + 
                    (this.state.gesture.side === 'left' ? delta : -delta);
                val = this._elastic(val, this.config.margin.min, this.config.margin.max);

                const contentHeight = this.el.content.scrollHeight;

                if (this.state.gesture.side === 'left') {
                    this.state.marginL = val;
                    this.el.dragZoneL.style.width = Math.max(60, val) + 'px';
                    this.el.dragZoneL.style.height = contentHeight + 'px';
                } else {
                    this.state.marginR = val;
                    this.el.dragZoneR.style.width = Math.max(60, val) + 'px';
                    this.el.dragZoneR.style.height = contentHeight + 'px';
                }
                
                this.updateStyles();
            }

            _stopMarginDrag() {
                if (this.state.gesture.dragging) {
                    const zone = this.state.gesture.side === 'left' ? this.el.dragZoneL : this.el.dragZoneR;
                    if (zone) zone.classList.remove('active');
                    
                    const isLeft = this.state.gesture.side === 'left';
                    const cur = isLeft ? this.state.marginL : this.state.marginR;
                    const final = this._clamp(cur, this.config.margin.min, this.config.margin.max);
                    const contentHeight = this.el.content.scrollHeight;
                    
                    if (isLeft) {
                        this.state.marginL = final;
                        this.el.dragZoneL.style.width = Math.max(60, final) + 'px';
                        this.el.dragZoneL.style.height = contentHeight + 'px';
                    } else {
                        this.state.marginR = final;
                        this.el.dragZoneR.style.width = Math.max(60, final) + 'px';
                        this.el.dragZoneR.style.height = contentHeight + 'px';
                    }
                    
                    this.updateStyles();
                }
                
                this.state.gesture.dragging = false;
                this.state.gesture.side = null;
            }

            _handleTouchStart(e) {
                if (this.state.gesture.dragging) return;
                this.state.gesture.touches = [...e.touches];
                
                if (e.touches.length === 2) {
                    e.preventDefault();
                    this.state.gesture.initDist = this._dist(e.touches[0], e.touches[1]);
                    this.state.gesture.initSize = this.state.fontSize;
                }
            }

            _handleTouchMove(e) {
                if (this.state.gesture.dragging || e.touches.length !== 2) return;
                e.preventDefault();

                const curDist = this._dist(e.touches[0], e.touches[1]);
                const distChange = Math.abs(curDist - this.state.gesture.initDist);

                const mid1 = {
                    x: (this.state.gesture.touches[0].clientX + this.state.gesture.touches[1].clientX) / 2,
                    y: (this.state.gesture.touches[0].clientY + this.state.gesture.touches[1].clientY) / 2
                };
                const mid2 = {
                    x: (e.touches[0].clientX + e.touches[1].clientX) / 2,
                    y: (e.touches[0].clientY + e.touches[1].clientY) / 2
                };
                const midDelta = {
                    x: Math.abs(mid2.x - mid1.x),
                    y: Math.abs(mid2.y - mid1.y)
                };

                if (distChange > 10 && distChange > midDelta.x && distChange > midDelta.y) {
                    const scale = curDist / this.state.gesture.initDist;
                    this.state.fontSize = this._clamp(
                        this.state.gesture.initSize * scale,
                        this.config.fontSize.min,
                        this.config.fontSize.max
                    );
                    this.updateStyles();
                }
            }

            _handleWheel(e) {
                if (e.ctrlKey || e.metaKey) {
                    e.preventDefault();
                    this.state.fontSize = this._clamp(
                        this.state.fontSize - e.deltaY * 0.1,
                        this.config.fontSize.min,
                        this.config.fontSize.max
                    );
                    this.updateStyles();
                }
            }

            _handleScroll() {
                this.state.flow.userScroll = true;
                clearTimeout(this._scrollTimeout);
                this._scrollTimeout = setTimeout(() => {
                    this.state.flow.userScroll = false;
                }, this.config.scroll.timeout);
            }

            _clamp(v, min, max) {
                return Math.max(min, Math.min(max, v));
            }

            _elastic(v, min, max) {
                return v < min ? min - Math.sqrt(min - v) * 2 :
                       v > max ? max + Math.sqrt(v - max) * 2 : v;
            }

            _dist(t1, t2) {
                return Math.hypot(t2.clientX - t1.clientX, t2.clientY - t1.clientY);
            }
        }

        // ============================================================================
        // EXPOSE LIBRARY
        // ============================================================================

        window.EBookReader = EBookReader;
        window.EBookReaderError = EBookReaderError;
        window.ConfigurationError = ConfigurationError;
        window.ContentError = ContentError;
        window.StateError = StateError;

        // ============================================================================
        // EXAMPLE: EXTERNAL UI CONTROLLER
        // ============================================================================

        const sampleContent = `
            <h1>Chapter One: The Beginning</h1>
            <p>In the heart of Silicon Valley, where innovation breathed life into dreams and ambition fueled the relentless pursuit of progress, there existed a small startup that dared to challenge the giants. The morning sun cast long shadows through the floor-to-ceiling windows of their modest office, illuminating screens filled with code and whiteboards covered in sketches of impossible ideas.</p>
            <p>Sarah had always believed that the best products were born from frustration. It was a Tuesday afternoon when she threw her e-reader across the roomâ€”not hard enough to break it, but with enough force to express her complete dissatisfaction with the experience. "Why," she asked her co-founder Marcus, "does every reading app feel like it was designed in 2010?"</p>
            <p>Marcus looked up from his laptop, his fingers still hovering over the keyboard. He'd been wrestling with the same question for months. The reading experience hadn't evolved. Sure, screens got sharper and devices got thinner, but the fundamental interaction between human and text remained stubbornly unchanged.</p>
            <p>They spent the next six months in a frenzy of prototyping. Coffee cups multiplied across their desks. Whiteboards filled with user flow diagrams. They interviewed hundreds of readersâ€”commuters on trains, students in libraries, professionals in coffee shops. What they discovered was simple: people didn't just want to read faster. They wanted to read better.</p>
            <p>The breakthrough came on a rainy November evening. Sarah was testing their latest prototype when something clicked. The text moved with her eyes, not against them. Words highlighted in rhythm with her reading speed. It felt like the book was reading her mind.</p>
            <p>"This is it," she whispered, looking up at Marcus with wide eyes. "This is what we've been searching for."</p>
            <p>Marcus leaned over her shoulder, watching the prototype in action. For the first time in months, he smiled. Really smiled. Not the forced grin of another failed demo, but the genuine expression of someone who knew they'd created something special.</p>
            <p>They called it Flow Mode. The name came naturallyâ€”it was exactly how reading felt when everything worked perfectly. No friction. No distraction. Just you and the words, moving together in perfect harmony.</p>
            <p>The technology behind it was complex. Machine learning algorithms predicted reading patterns. Eye-tracking data refined the timing. Natural language processing identified logical pause points. But the experience was effortless. That was the magic.</p>
            <p>Launch day arrived faster than they expected. Sarah stood at the window of their small office, watching the city wake up. In a few hours, they would release Flow Mode to the world. Years of work, countless sleepless nights, and more coffee than she cared to countâ€”all culminating in this moment.</p>
            <p>"Ready?" Marcus asked, his finger hovering over the deployment button.</p>
            <p>Sarah took a deep breath. "Ready."</p>
            <p>The first users started trickling in within minutes. Then dozens. Then hundreds. The server metrics climbed steadily as readers around the world discovered a new way to experience text. Comments began appearing in their feedback channels:</p>
            <p>"I just read an entire chapter without looking away once."</p>
            <p>"This is how I've always wanted to read."</p>
            <p>"Where has this been all my life?"</p>
            <p>By noon, they had a thousand users. By evening, ten thousand. The numbers kept climbing. Sarah and Marcus watched in amazement as their little experiment transformed into something bigger than they'd ever imagined.</p>
            <p>But the real validation came from an unexpected source. A teacher in rural Ohio sent them an email about a student with dyslexia. Flow Mode had changed everything. For the first time, this student could keep up with classmates. The words no longer jumbled together. Reading became not just possible, but enjoyable.</p>
            <p>Sarah read the email three times, tears streaming down her face. This was why they built it. Not for the metrics or the user growth, but for moments like this. For the people who struggled with traditional reading, who felt left behind by static text on unchanging pages.</p>
            <p>The coming months brought new challenges. Scaling servers. Managing growth. Hiring a team. The startup life demanded everything from them. Early mornings bled into late nights. Weekends became indistinguishable from weekdays. But they never lost sight of why they started.</p>
            <p>They added new features. Bionic reading mode that emphasized key parts of words. Customizable focus widths for different reading styles. Scroll positioning that adapted to individual preferences. Each addition was tested meticulously, refined endlessly, perfected obsessively.</p>
            <p>Users responded enthusiastically. The community grew. Discussions sparked about reading techniques, optimal speeds, best practices. People shared their experiences, compared settings, helped newcomers find their flow. It became more than just an appâ€”it became a movement.</p>
            <p>Sarah still remembered the day they hit a million users. She and Marcus stood in their now much larger office, surrounded by a team of talented engineers and designers, watching the counter tick over. They'd come so far from that rainy November evening.</p>
            <p>"You know what the best part is?" Marcus said, pulling up their latest feedback report. "Ninety-seven percent retention rate. People aren't just trying itâ€”they're sticking with it. It's becoming part of their daily routine."</p>
            <p>Sarah nodded, but her attention was elsewhere. She was reading through support tickets, looking for problems to solve, improvements to make. There was always more work to do. Always another way to make the experience better.</p>
            <p>That evening, as the office emptied and the city lights began to twinkle below, Sarah opened the app on her phone. She loaded her favorite book and hit play. The words flowed across the screen in perfect rhythm, highlighting and scrolling exactly as she expected. After building it for so long, she sometimes forgot to just use it.</p>
            <p>But now, reading with Flow Mode felt like coming home. The technology faded into the background. The interface became invisible. There was only her and the story, moving together through the narrative with effortless grace.</p>
            <p>This was what they'd created. Not just an app or a product or a company. They'd built a bridge between readers and stories, making the connection smoother, stronger, more profound. And they were just getting started.</p>
        `;

        // Initialize core library
        window.reader = new EBookReader('#reader-container');
        reader.loadContent(sampleContent);

        // Connect external UI to library
        const btnBionic = document.getElementById('btn-bionic');
        const btnFlow = document.getElementById('btn-flow');
        const btnPlay = document.getElementById('btn-play');
        const flowControls = document.getElementById('flow-controls');
        const speedSlider = document.getElementById('speed-slider');
        const speedLabel = document.getElementById('speed-label');
        const focusSlider = document.getElementById('focus-slider');
        const focusLabel = document.getElementById('focus-label');
        const scrollSlider = document.getElementById('scroll-slider');
        const scrollLabel = document.getElementById('scroll-label');

        // Wire up buttons to library API
        btnBionic.addEventListener('click', () => {
            reader.setBionic(!reader.getState().bionic);
            btnBionic.classList.toggle('active');
        });

        btnFlow.addEventListener('click', () => {
            const currentMode = reader.getState().mode;
            const newMode = currentMode === 'flow' ? 'normal' : 'flow';
            reader.setMode(newMode);
            btnFlow.classList.toggle('active', newMode === 'flow');
            flowControls.style.display = newMode === 'flow' ? 'flex' : 'none';
            
            // Auto-play when entering flow mode
            if (newMode === 'flow') {
                setTimeout(() => reader.play(), 150);
            }
        });

        btnPlay.addEventListener('click', () => {
            reader.togglePlay();
        });

        speedSlider.addEventListener('input', (e) => {
            reader.setSpeed(+e.target.value);
            speedLabel.textContent = e.target.value + ' wpm';
        });

        focusSlider.addEventListener('input', (e) => {
            reader.setFocusWidth(+e.target.value);
            focusLabel.textContent = e.target.value;
        });

        scrollSlider.addEventListener('input', (e) => {
            const level = +e.target.value;
            reader.setScrollLevel(level);
            const labels = ['Top', 'Upper', 'Middle', 'Lower', 'Bottom'];
            scrollLabel.textContent = labels[level - 1];
        });

        // Listen to library events
        reader.on('onPlayChange', (isPlaying) => {
            btnPlay.textContent = isPlaying ? 'â¸ Pause' : 'â–¶ Play';
        });

        // Log initialization
        console.log('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—');
        console.log('â•‘ EBookReader v' + EBookReader.VERSION + ' - COMFORT ZONE  â•‘');
        console.log('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
        console.log('');
        console.log('ðŸŽ¯ COMFORT ZONE SCROLLING:');
        console.log('   â€¢ Word floats freely in zone (15%-70%)');
        console.log('   â€¢ Only scrolls when exiting zone');
        console.log('   â€¢ Browser handles smooth scroll');
        console.log('   â€¢ 90% no scroll = perfectly smooth');
        console.log('   â€¢ 10% gentle corrections');
        console.log('');
        console.log('âœ¨ WHY IT\'S SMOOTH:');
        console.log('   âœ“ Less is more - scroll only when needed');
        console.log('   âœ“ Browser\'s native smooth scroll');
        console.log('   âœ“ No micro-corrections or jitter');
    </script>
</body>
</html>